/*
 * Created by SharpDevelop.
 * User: sergey.lezhenko
 * Date: 18.09.2017
 * Time: 10:54
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
using System;
using System.Collections;
using System.Linq;
using System.Reflection;
using System.Text;

namespace DZ_LINQ
{
    public static class ExMethods
    {
        public static void Show(this IEnumerable seq)
        {
            IEnumerator el = seq.GetEnumerator();
            while (el.MoveNext())
            {
                Console.Write(el.Current + " ");
            }
        }
    }
    class Program
    {
        static void Task0()
        {
            Console.WriteLine("Good buy!");
        }
        static void Task1()
        {
            Console.WriteLine(
                "\nLinqBegin1\n"
                + "Дана целочисленная последовательность, содержащая\n"
                + "как положительные, так и отрицательные числа.Вывести ее первый\n"
                + "положительный элемент и последний отрицательный элемент.\n"
                + "int[] e = { 4, 12, -6, -4, -32, 47, 32, 96, 0, 23, -5, -3, -75, 15 }");
            int[] e = { 4, 12, -6, -4, -32, 47, 32, 96, 0, 23, -5, -3, -75, 15 };
            Console.WriteLine(e.FirstOrDefault(a => a > 0));
            Console.WriteLine(e.LastOrDefault(a => a < 0));
        }
        static void Task2()
        {
            Console.WriteLine(
                "\nLinqBegin2\n"
                + "Даны цифра D (однозначное целое число) и целочисленная последовательность A.\n"
                + "Вывести первый положительный элемент последовательности A, оканчивающийся цифрой  D.\n"
                + "Если требуемых элементов в последовательности A нет, то вывести 0.\n"
                + "int D = 2;\n"
                + "int[] A = { 4, 12, -6, -4, -32, 47, 32, 96, 0, 23, -5, -3, -75, 15 };");
            int D = 2;
            int[] A = { 4, 12, -6, -4, -32, 47, 32, 96, 0, 23, -5, -3, -75, 15 };
            Console.WriteLine(
                A.FirstOrDefault(r => r > 0 && r.ToString().EndsWith(D.ToString(), StringComparison.CurrentCulture))
                );
        }
        static void Task3()
        {
            Console.WriteLine(
                "\nLinqBegin3\n"
                + "Даны целое число L(> 0) и строковая последовательность A.\n"
                + "Вывести последнюю строку из A, начинающуюся с цифры и имеющую длину L.\n"
                + "Если требуемых строк в последовательности A нет, то вывести строку «Not found».\n"
                + "Указание.Для обработки ситуации, связанной с отсутствием требуемых строк, использовать операцию ??."
                + "int L = 4;\n"
                + "string[] A = { \"8pOl\", \"\", \"OOHNG\", \"2J\", \"jle\", \"ojRa\", \"UTq\", \"4A3\", \"\", \"bh\", \"p\", \"daW\" };"
                );
            int L = 4;
            string[] A = { "8pOl", "", "OOHNG", "2J", "jle", "ojRa", "UTq", "4A3", "", "bh", "p", "daW" };
            Console.WriteLine(
                A.LastOrDefault(r => r.Length == L && r.IndexOfAny(
                    new[] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' }) == 0) ?? "Not found"
                );
        }
        static void Task4()
        {
            Console.WriteLine(
                "\nLinqBegin4:\n"
                + "Даны символ С и строковая последовательность A.\n"
                + "Если A содержит единственный элемент, оканчивающийся символом C,\n"
                + "то вывести этот элемент; если требуемых строк в A нет, то\n"
                + "вывести пустую строку; если требуемых строк больше одной, то вывести строку «Error».\n"
                + "Указание.Использовать try-блок для перехвата возможного исключения.\n"
                + "Примечание.Решение данной задачи приведено в п. 5.1.\n"
                + "const char c = 'l';\n"
                + "string[] A = { \"8pOvl\", \"\", \"OOHNG\", \"2J\", \"jle\", \"ojRa\", \"UTq\", \"4A3\", \"\", \"bh\", \"p\", \"daW\" };\n");
            const char c = 'l';
            string[] A = { "8pOvl", "", "OOHNG", "2J", "jle", "ojRa", "UTq", "4A3", "", "bh", "p", "daW" };
            try
            {
                Console.WriteLine(
                    A.SingleOrDefault(e => e.Length != 0 && e[e.Length - 1] == c) ?? ""
                    );
            }
            catch
            {
                Console.WriteLine("Error");
            }
        }
        static void Task5()
        {
            Console.WriteLine(
                "\nLinqBegin5\n"
                + "Даны символ С и строковая последовательность A.\n"
                + "Найти количество элементов A, которые содержат более одного\n"
                + "символа и при этом начинаются и оканчиваются символом C.\n"
                + "char C = 'O';\n"
                + "string[] A = { \"8pOl\", \"\", \"OOHNGO\", \"2J\", \"OjleO\", \"ojRa\", \"OUOTq\", \"4A3\", \"\", \"bh\", \"p\", \"daW\" };\n"
                );
            char C = 'O';
            string[] A = { "8pOl", "", "OOHNGO", "2J", "OjleO", "ojRa", "OUOTq", "4A3", "", "bh", "p", "daW" };
            Console.WriteLine(
                A.Count(r => r.Length > 1
                && r.StartsWith(C.ToString(), StringComparison.Ordinal)
                && r.EndsWith(C.ToString(), StringComparison.Ordinal))
                );
        }
        static void Task6()
        {
            Console.WriteLine(
                "\nLinqBegin6\n"
                + "Дана строковая последовательность.\n"
                + "Найти сумму длин всех строк, входящих в данную последовательность.\n"
                + "string[] A = { \"8pOl\", \"\", \"OOHNGO\", \"2J\", \"OjleO\", \"ojRa\", \"OUOTq\", \"4A3\", \"\", \"bh\", \"p\", \"daW\" };\n"
                );
            string[] A = { "8pOl", "", "OOHNGO", "2J", "OjleO", "ojRa", "OUOTq", "4A3", "", "bh", "p", "daW" };
            Console.Write(
                A.Sum(r => r.Length)
                );
        }
        static void Task7()
        {
            Console.WriteLine(
                "\nLinqBegin7\n"
                + "Дана целочисленная последовательность.\n"
                + "Найти количество ее отрицательных элементов, а также их сумму.\n"
                + "Если отрицательные элементы отсутствуют, то дважды вывести 0.\n"
                + "int[] A = { 4, 12, -6, 4, -32, -47, 32, 96, 0, 23, 5, -3, -75, 15 };\n"
                );
            int[] A = { 4, 12, -6, 4, -32, -47, 32, 96, 0, 23, 5, -3, -75, 15 };
            Console.WriteLine(
                "Count = {0}, Sum = {1}",
                A.Count(r => r < 0), A.Sum(r => r < 0 ? r : 0)
                );
        }
        static void Task8()
        {
            Console.WriteLine(
                "\nLinqBegin8\n"
                + "Дана целочисленная последовательность.\n"
                + "Найти количество ее положительных двузначных элементов,\n"
                + "а также их среднее арифметическое (как вещественное число).\n"
                + "Если требуемые элементы отсутствуют, то дважды вывести 0 \n"
                + "(первый раз как целое, второй – как вещественное).\n"
                + "int[] A = { -4, -12, -6, -4, 32, -47, 32, -96, 0, 23, -5, 3, -75, -15 };");
            int[] A = { -4, -12, -6, -4, 32, -47, 32, -96, 0, 23, -5, 3, -75, -15 };
            var res = from a in A
                      where a > 0 && a.ToString().Length == 2
                      select a;
            Console.WriteLine(
                "Count = {0}, Sum = {1}",
                res.Count(),
                res.Count() > 0 ? res.Average() : 0.0);
        }
        static void Task9()
        {
            Console.WriteLine(
                "\nLinqBegin9\n"
                + "Дана целочисленная последовательность.\n"
                + "Вывести ее минимальный положительный элемент или число 0,\n"
                + "если последовательность не содержит положительных элементов.\n"
                + "int[] A = { -4, -12, -6, -4, 32, -47, -32, 96, -23, -5, 3, -75, -15 };\n"
                + "\n"
                + "\n"
                + "\n");
            int[] A = { -4, -12, -6, -4, 32, -47, -32, 96, -23, -5, 3, -75, -15 };
            var res = from a in A
                      where a > 0
                      select a;
            Console.WriteLine(
                "Min = {0}",
                res.Count() > 0 ? res.Min() : 0);
        }
        static void Task10()
        {
            Console.WriteLine(
                "\nLinqBegin10\n"
                + "Даны целое число L(> 0) и строковая последовательность A.\n"
                + "Строки последовательности A содержат только заглавные буквы латинского алфавита.\n"
                + "Среди всех строк из A, имеющих длину L, найти наибольшую (в смысле лексикографического порядка).\n"
                + "Вывести эту строку или пустую строку, если последовательность не содержит строк длины L.\n"
                + "int L = 5;\n"
                + "string[] A = { \"HDSJ\", \"\", \"OOHNGO\", \"J\", \"OSFHO\", \"HTREWDA\", \"WUGOT\", \"EW\", \"QWRQRQ\", \"QWERG\", \"WERGX\", \"FASSS\" };"
                );
            int L = 5;
            string[] A = { "HDSJ", "", "OOHNGO", "J", "OSFHO", "HTREWDA", "WUGOT", "EW", "QWRQRQ", "QWERG", "WERGX", "FASSS" };
            Console.WriteLine(
                "Max str = {0}",
                (from a in A
                 where a.Length == L
                 orderby a descending
                 select a)
                 .FirstOrDefault() ?? "");
        }
        static void Task11()
        {
            Console.WriteLine(
                "\nLinqBegin11\n"
                + "Дана последовательность непустых строк.\n"
                + "Используя метод Aggregate, получить строку, состоящую из\n"
                + "начальных символов всех строк исходной последовательности.\n"
                + "string[] A = { \"HDSJ\", \"\", \"OOHNGO\", \"J\", \"OSFHO\", \"HTREWDA\", \"WUGOT\", \"EW\", \"QWRQRQ\", \"QWERG\", \"WERGX\", \"FASSS\" };"
                );
            string[] A = { "HDSJ", "", "OOHNGO", "J", "OSFHO", "HTREWDA", "WUGOT", "EW", "QWRQRQ", "QWERG", "WERGX", "FASSS" };
            Console.WriteLine(
                "Aggregate str = {0}",
                (from a in A
                 where (a != null && a.Length > 0)
                 select a[0])
                 .Aggregate("", (r, c) => r + c));
        }
        static void Task12()
        {
            Console.WriteLine(
                "\nLinqBegin12\n"
                + "Дана целочисленная последовательность.\n"
                + "Используя метод Aggregate, найти произведение последних цифр\n"
                + "всех элементов последовательности.\n"
                + "Чтобы избежать целочисленного переполнения,\n"
                + "при вычислении произведения использовать вещественный числовой тип.\n"
                + "int[] A = { -4, 12, -6, -4, 32, -47, -32, 96, -23, -5, 3, -75, -15 };"
                );
            int[] A = { -4, 12, -6, -4, 32, -47, -32, 96, -23, -5, 3, -75, -15 };
            Console.WriteLine(
                "Mult = {0}",
                (from a in A
                 let r = Char.GetNumericValue(a.ToString().LastOrDefault())
                 select r)
                 .Aggregate(1.0, (i, j) => i * j));
        }
        static void Task13()
        {
            Console.WriteLine(
                "\nLinqBegin13\n"
                + "Дано целое число N (> 0). Используя методы Range\n"
                + "и Sum, найти сумму 1 + (1/2) + … + (1/N) (как вещественное число).\n"
                + "int A = 6;"
                );
            int A = 6;
            Console.WriteLine(
                "Sum = {0}",
                Enumerable.Range(1, A)
                .Sum(i => (1.0 / i)));
        }
        static void Task14()
        {
            Console.WriteLine(
                "\nLinqBegin14\n"
                + "Даны целые числа A и B(A< B).\n"
                + "Используя мето-ды Range и Average, найти среднее арифметическое квадратов всех\n"
                + "целых чисел от A до B включительно:\n"
                + "(A^2 + (A + 1)^2 + … + B^2)/(B – A + 1) (как вещественное число).\n"
                + "int A = 5, B = 10;");
            int A = 5, B = 10;
            Console.WriteLine(
                "Avg = {0}",
                Enumerable.Range(A, B - A + 1)
                .Average(i => i * i));
        }
        static void Task15()
        {
            Console.WriteLine(
                "\nLinqBegin15:\n"
                + "Дано целое число N(0 <= N <= 15). Используя методы Range и Aggregate,\n"
                + "найти факториал числа N: N! = 1·2·…·N при N >= 1; 0! = 1.\n"
                + "Чтобы избежать целочисленного переполнения, при\n"
                + "вычислении факториала использовать вещественный числовой тип.\n"
                + "Примечание.Решение данной задачи приведено в п. 5.2.\n"
                + "const int N = 5;");
            int N = 5;
            Console.WriteLine(
                Enumerable.Range(1, N)
                .Aggregate(1.0, (a, e) => a * e));
        }
        //2.2. Фильтрация, сортировка,
        //теоретико-множественные операции
        //Изучаемые запросы LINQ:
        //Where , TakeWhile , SkipWhile , Take , Skip (фильтрация);
        //OrderBy , OrderByDescending , ThenBy , ThenByDescending (сортировка);
        //Distinct , Reverse (удаление повторяющихся элементов и инвертирование);
        //Union , Intersect , Except (теоретико-множественные операции)
        static void Task16()
        {
            Console.WriteLine(
                "\nLinqBegin16:\n"
                + "Дана целочисленная последовательность.\n"
                + "Извлечь из нее все положительные числа,\n"
                + "сохранив их исходный порядок следования.\n"
                + "int[] A = { -4, 12, -6, -4, 32, -47, -32, 96, -23, -5, 3, -75, -15 };");
            int[] A = { -4, 12, -6, -4, 32, -47, -32, 96, -23, -5, 3, -75, -15 };
            (from a in A
             where a > 0
             select a).Show();
            Console.WriteLine();
        }
        static void Task17()
        {
            Console.WriteLine(
                "\nLinqBegin17\n"
                + "Дана целочисленная последовательность.\n"
                + "Извлечь из нее все нечетные числа, сохранив их исходный порядок следования\n"
                + "и удалив все вхождения повторяющихся элементов, кроме первых.\n"
                + "int[] A = { -4, 12, -6, -4, 32, -47, -32, 96, -23, -5, 3, -75, -15 };");
            int[] A = { -4, 12, -6, -4, 32, -47, -32, 96, -23, -5, 3, -75, -15 };
            (from a in A
             where a % 2 != 0
             select a).Distinct().Show();
        }
        static void Task18()
        {
            Console.WriteLine(
                "\nLinqBegin18\n"
                + "Дана целочисленная последовательность.\n"
                + "Извлечь из нее все четные отрицательные числа,\n"
                + "поменяв порядок извлеченных чисел на обратный.\n"
                + "int[] A = { -4, 12, -6, -4, 32, -47, -32, 96, -23, -5, 3, -75, -15 };");
            int[] A = { -4, 12, -6, -4, 32, -47, -32, 96, -23, -5, 3, -75, -15 };
            (from a in A
             where a % 2 != 0 && a < 0
             select a).Reverse().Show();
        }
        static void Task19()
        {
            Console.WriteLine(
                "\nLinqBegin19\n"
                + "Даны цифра D(целое однозначное число) и целочисленная последовательность A.\n"
                + "Извлечь из A все различные положительные числа, оканчивающиеся цифрой D(в исходном порядке).\n"
                + "При наличии повторяющихся элементов удалять все их вхождения, кроме последних.\n"
                + "Указание.Последовательно применить методы Reverse, Distinct, Reverse.\n"
                + "int D = 4;\n"
                + "int[] A = { -4, 12, -6, -4, 34, -47, -34, 96, -24, -5, 34, 3, -75, -4, -15 };\n"
                + "\n");
            int D = 4;
            int[] A = { -4, 12, -6, -4, 34, -47, -34, 96, -24, -5, 34, 3, -75, -4, -15 };
            (from a in A
             where a.ToString().EndsWith(D.ToString())
             select a).Reverse().Distinct().Reverse().Show();
        }
        static void Task20()
        {
            Console.WriteLine(
                "\nLinqBegin20\n"
                + "Дана целочисленная последовательность.\n"
                + "Извлечь из нее все положительные двузначные числа,\n"
                + "отсортировав их по возрастанию.\n"
                + "int[] A = { -4, 12, -6, -4, 34, -47, -34, 96, -24, -5, 34, 3, -75, -4, -15 };");
            int[] A = { -4, 12, -6, -4, 34, -47, -34, 96, -24, -5, 34, 3, -75, -4, -15 };
            (from a in A
             where a > 0 && a.ToString().Length == 2
             orderby a
             select a).Show();
        }
        static void Task21()
        {
            Console.WriteLine(
                "\nLinqBegin21\n"
                + "Дана строковая последовательность.\n"
                + "Строки последовательности содержат только заглавные буквы латинского алфавита.\n"
                + "Отсортировать последовательность по возрастанию длин строк,\n"
                + "а строки одинаковой длины – в лексикографическом порядке по убыванию.\n"
                + "string[] A = { \"HDSJ\", \"\", \"OOHNGO\", \"J\", \"OSFHO\", \"HTREWDA\", \"WUGOT\", \"EW\", \"QWRQRQ\", \"QWERG\", \"WERGX\", \"FASSS\" };\n");
            string[] A = { "HDSJ", "", "OOHNGO", "J", "OSFHO", "HTREWDA", "WUGOT", "EW", "QWRQRQ", "QWERG", "WERGX", "FASSS" };
            A.OrderByDescending(a => a).OrderBy(a => a.Length).Show();
        }
        static void Task22()
        {
            Console.WriteLine(
                "\nLinqBegin22\n"
                + "Даны целое число K(> 0) и строковая последовательность A.\n"
                + "Строки последовательности содержат только цифры\n"
                + "и заглавные буквы латинского алфавита.\n"
                + "Извлечь из A все строки длины K, оканчивающиеся цифрой,\n"
                + "отсортировав их в лексикографическом порядке по возрастанию.\n"
                + "int K = 5;\n"
                + "string[] A = { \"HDSJ5\", \"\", \"OOH3N4GO\", \"J3\", \"O5SHO\", \"H5TREWDA\", \"WUGOT\", \"EW7\", \"Q6WRQR4Q4\", \"Q3WERG1\", \"W6ERG6X\", \"FASSS8\" };");
            int K = 5;
            string[] A = { "HDSJ5", "", "OOH3N4GO", "J3", "O5SFHO", "H5TREWDA", "WU7GOT", "EW7", "Q64Q4", "Q3RG1", "W6ERG6X", "FASSS8" };
            (from a in A
             where a.Length == K && a.LastOrDefault() > '0' && a.LastOrDefault() < '9'
             orderby a
             select a).Show();
        }
        static void Task23()
        {
            Console.WriteLine(
                "LinqBegin23\n"
                + "Даны целое число K(> 0) и целочисленная последовательность A.\n"
                + "Начиная с элемента A с порядковым номером K,\n"
                + "извлечь из A все нечетные двузначные числа, отсортировав их по убыванию.\n"
                + "int K = 5;\n"
                + "int[] A = { 5, 6, 8, 12, 43, 67, 876, 54, 65, 73, 13 };\n");
            int K = 5;
            int[] A = { 5, 6, 8, 12, 43, 67, 876, 54, 65, 73, 13 };
            (from a in A.Skip(K - 1)
             where a % 2 != 0
             orderby a descending
             select a).Show();
        }
        static void Task24()
        {
            Console.WriteLine(
                "LinqBegin24\n"
                + "Даны целое число K(> 0) и строковая последовательность A.\n"
                + "Из элементов A, предшествующих элементу с порядковым номером K,\n"
                + "извлечь те строки, которые имеют нечетную длину и начинаются с заглавной латинской буквы,\n"
                + "изменив порядок следования извлеченных строк на обратный.\n"
                + "int K = 5;\n"
                + "string[] A = { \"HDSJ\", \"\", \"OOHNG\", \"j\", \"OSFHO\", \"hTREWDA\", \"WUGOT\", \"EW\", \"QWRQRQ\", \"QWERG\", \"WERGX\", \"FASSS\" };\n");
            int K = 7;
            string[] A = { "HDSJ", "", "OOHNG", "j", "OSFHO", "hTREWDA", "WUGOT", "EW", "QWRQRQ", "QWERG", "WERGX", "FASSS" };
            (from a in A.Take(K - 1)
             where a.Length % 2 != 0 && a[0] >= 'A' && a[0] <= 'Z'
             select a).Reverse().Show();
        }
        static void Task25()
        {
            Console.WriteLine(
                "LinqBegin25\n"
                + "Даны целые числа K1 и K2 и целочисленная последовательность A;\n"
                + "1 <= K1 < K2 <= N, где N–размер последовательности A.\n"
                + "Найти сумму положительных элементов последовательности\n"
                + "с порядковыми номерами от K1 до K2 включительно.\n"
                + "int K1 = 3;\n"
                + "int K2 = 7;\n"
                + "int[] A = { 4, -6, 19, -5, -7, 23, 14, -3, 16 };\n");
            int K1 = 3;
            int K2 = 7;
            int[] A = { 4, -6, 19, -5, -7, 23, 14, -3, 16 };
            Console.WriteLine((from a in A.Skip(K1 - 1).Take(K2 - K1 + 1)
             where a > 0
             select a).Sum());
        }
        static void Task26()
        {
            Console.WriteLine(
                "LinqBegin26\n"
                + "Даны целые числа K1 и K2 и последовательность непустых строк A;\n"
                + "1 < K1 < K2 <= N, где N–размер последовательности A.\n"
                + "Найти среднее арифметическое длин всех элементов последовательности,\n"
                + "кроме элементов с порядковыми номерами от K1 до K2\n"
                + "включительно, и вывести его как вещественное число.\n"
                + "int K1 = 3;\n"
                + "int K2 = 5;\n"
                + "string[] A = { \"HDSJ\", \"OOHNG\", \"j\", \"OSFHO\", \"hTREWDA\", \"WUGOT\", \"EW\", \"QWRQRQ\", \"QWERG\", \"WERGX\", \"FASSS\" };\n");
            int K1 = 3;
            int K2 = 5;
            string[] A = { "HDSJ", "OOHNG", "j", "OSFHO", "hTREWDA", "WUGOT", "EW", "QWRQRQ", "QWERG", "WERGX", "FASSS" };
            Console.WriteLine((from a in A.Where((a, n) => n < K1 - 1 || n > K2 - 1)
             select a.Length).Average());
        }
        static void Task27()
        {
            Console.WriteLine(
                "LinqBegin27\n"
                + "Даны целое число D и целочисленная последовательность A.\n"
                + "Начиная с первого элемента A, большего D, извлечь из\n"
                + "A все нечетные положительные числа, поменяв порядок извлеченных чисел на обратный.\n"
                + "int D = 9;\n"
                + "int[] A = { 4, -6, 19, -5, -7, 23, 14, -3, 5 };\n");
            int D = 9;
            int[] A = { 4, -6, 19, -5, -7, 23, 14, -3, 5 };
            (from a in A.SkipWhile(a => a <= D)
             where a % 2 != 0 && a > 0
             select a).Reverse().Show();
        }
        static void Task28()
        {
            Console.WriteLine(
@"LinqBegin28
Даны целое число L(> 0) и последовательность непустых строк A.
Строки последовательности содержат только цифры и заглавные буквы латинского алфавита.
Из элементов A, предшествующих первому элементу, длина которого превышает L, извлечь
строки, оканчивающиеся буквой. Полученную последовательность
отсортировать по убыванию длин строк, а строки одинаковой длины –
в лексикографическом порядке по возрастанию.
int L = 5;
string[] A = { ""FSG4"", ""GTD"", ""5FDB"", ""G"", ""D5BT"", ""TR53F"", ""RT5DBG"", ""GT54D"" };\n");
            int L = 5;
            string[] A = { "FSG4", "GTD", "5FDB", "G", "D5BT", "TR53F", "RT5DBG", "GT54D" };
            (from a in A.TakeWhile(a => a.Length <= L)
             where a[a.Length - 1] >= 'A' && a[a.Length - 1] <= 'Z'
             orderby a
             select a).OrderByDescending(a => a.Length).Show();
        }
        static void Task29()
        {
            Console.WriteLine(@"LinqBegin29
Даны целые числа D и K(K> 0) и целочисленная последовательность A.
Найти теоретико-множественное объединение двух фрагментов A:
первый содержит все элементы до первого элемента, большего D(не включая его),
а второй – все элементы, начиная с элемента с порядковым номером K.
Полученную последовательность (не содержащую одинаковых элементов) отсортировать по убыванию.
int D = 3;
int K = 5;
int[] A = { 2, -6, 19, -5, -7, 23, 14, -3, 5 };");
            int D = 3;
            int K = 5;
            int[] A = { 2, -6, 19, -5, -7, 23, 14, -3, 5 };
            (from a in A.TakeWhile(a => a < D).Union(A.Skip(K - 1))
             orderby a descending
             select a).Show();
        }
        static void Task30()
        {
            Console.WriteLine(@"LinqBegin30
Даны целое число K(> 0) и целочисленная последовательность A.
Найти теоретико-множественную разность двух фрагментов A:
первый содержит все четные числа, а второй – все числа с порядковыми номерами, большими K.
В полученной последовательности (не содержащей одинаковых элементов) поменять
порядок элементов на обратный.
int K = 3;
int[] A = { 2, 4, -6, 19, -5, -7, 23, 14, -6, -3, 5 };");
            int K = 5;
            int[] A = { 2, 4, -6, 19, -5, -7, 23, 14, -6, -3, 5 };
            A.Where(a => a % 2 == 0).Except(A.Skip(K)).Reverse().Show();
        }
        static void Task31()
        {
            Console.WriteLine(@"LinqBegin31
Даны целое число K(> 0) и последовательность
непустых строк A. Строки последовательности содержат только
цифры и заглавные буквы латинского алфавита.
Найти теоретико-множественное пересечение двух фрагментов A: первый содержит
K начальных элементов, а второй – все элементы, расположенные
после последнего элемента, оканчивающегося цифрой. Полученную
последовательность (не содержащую одинаковых элементов) отсортировать
по возрастанию длин строк, а строки одинаковой длины –
в лексикографическом порядке по возрастанию.
Примечание. Решение данной задачи приведено в п. 5.3
int K = 4;
string[] A = { ""FSGL"", ""GTD"", ""5FDB"", ""G"", ""D5B5"", ""TR53"", ""GTD"", ""FSGL"", ""5FDB"", ""GT54D"" };\n");
			const int K = 4;
            string[] A = { "FSGL", "GTD", "5FDB", "G", "D5B5", "TR53", "GTD", "FSGL", "5FDB", "GT54D" };
            A.Take(K)
                .Intersect(
                A.Reverse()
                .TakeWhile(a => !char.IsDigit(a.Last())))
                .OrderBy(a => a.Length)
                .ThenBy(a=>a)
                .Show();
        }
        //2.3. Проецирование
        //Изучаемые запросы LINQ:
        //Select , SelectMany (проецирование).
        static void Task32()
        {
        	Console.WriteLine(@"LinqBegin32
Дана последовательность непустых строк A.
Получить последовательность символов, каждый элемент которой
является начальным символом соответствующей строки из A.
Порядок символов должен быть обратным по отношению к порядку
элементов исходной последовательности.
string[] A = {""gewfsd"",""vsdyut"",""wqxa"",""34fd"",""3ghfe"",""vscxt"",""vwevasnmy""};");
			string[] A = {
				"gewfsd",
				"vsdyut",
				"wqxa",
				"34fd",
				"3ghfe",
				"vscxt",
				"vwevasnmy"
			};
			A.Select(a => a[0]).Reverse().Show();
        }
        static void Task33()
        {
        	Console.WriteLine(@"LinqBegin33
Дана целочисленная последовательность.
Обрабатывая только положительные числа, получить последовательность
их последних цифр и удалить в полученной последовательности все
вхождения одинаковых цифр, кроме первого. Порядок полученных
цифр должен соответствовать порядку исходных чисел.
int[] A = { 15, 18, 9, -5, -7, 99, 35, -9, 16, 6, 3, 83 };");
			int[] A = { 15, 18, 9, -5, -7, 99, 35, -9, 16, 6, 3, 83 };
			(from a in A
			 where a > 0
			 select a % 10).Distinct().Show();
        }
        static void Task34()
        {
        	Console.WriteLine(@"LinqBegin34
Дана последовательность положительных целых чисел.
Обрабатывая только нечетные числа, получить последовательность
их строковых представлений и отсортировать ее в лексикографическом порядке по возрастанию.
int[] A = { 15, 18, 9, 99, 35, 16, 6, 3, 83 };");
        	int[] A = { 15, 18, 9, 99, 35, 16, 6, 3, 83 };
			(from a in A
			 where a % 2 == 1
			 select a.ToString()).OrderBy(a => a).Show();
        }
        static void Task35()
        {
			Console.WriteLine(@"LinqBegin35
Дана целочисленная последовательность. Получить
последовательность чисел, каждый элемент которой равен произведению
соответствующего элемента исходной последовательности на
его порядковый номер (1, 2, …). В полученной последовательности
удалить все элементы, не являющиеся двузначными,
и поменять порядок оставшихся элементов на обратный.
int[] A = { 4, -8, 18, 74, -6, 12, 63, -32, 33 };");
			int[] A = { 4, -8, 18, 74, -6, 12, 63, -32, 33 };
			(from a in A.Select((a, n) => a * (n + 1))
			 where Math.Abs(a) % 10 < 10 && Math.Abs(a) % 10 > 0
			 select a).Reverse().Show();
        }
        static void Task36()
        {
			Console.WriteLine(@"LinqBegin36.
Дана последовательность непустых строк. Получить
последовательность символов, которая определяется следующим образом:
если соответствующая строка исходной последовательности
имеет нечетную длину, то в качестве символа берется первый символ
этой строки; в противном случае берется последний символ строки.
Отсортировать полученные символы по убыванию их кодов.
string[] A = {""gewfsd"",""vsdyut"",""wqxa"",""34fd"",""3ghfe"",""vscxt"",""vwevasnmy""};");
			string[] A = {
				"gewfsd",
				"vsdyut",
				"wqxa",
				"34fd",
				"3ghfe",
				"vscxt",
				"vwevasnmy"
			};
			(A.Select(a => a.Length % 2 == 1 ? a.FirstOrDefault() : a.LastOrDefault())
        	 .OrderByDescending(a => a))
        		.Show();
        }
        static void Task37()
        {
			Console.WriteLine(@"LinqBegin37
Дана строковая последовательность A.
Строки последовательности содержат только заглавные буквы латинского алфавита.
Получить новую последовательность строк, элементы которой определяются
по соответствующим элементам A следующим образом:
пустые строки в новую последовательность не включаются,
а к непустым приписывается порядковый номер данной строки
в исходной последовательности (например, если пятый элемент A имеет
вид «ABC», то в полученной последовательности он будет иметь
вид «ABC5»). При нумерации должны учитываться и пустые строки
последовательности A. Отсортировать полученную последовательность
в лексикографическом порядке по возрастанию.
string[] A = {""HDFYL"",""WGHFHH"",""WEDSC"","""",""QEWF"",""WE"",""VWE"",""SFG"",""EWSXZ"",""GEHCFV"",""FWE"",""Q"",""XZD""};");
        	string[] A = {"HDFYL","WGHFHH","WEDSC","","QEWF","WE","VWE","SFG","EWSXZ","GEHCFV","FWE","Q","XZD"};
			(from a in A.Select((a, n) => (a.Length > 0) ? a + (n + 1) : "")
			       where a.Length > 0
			       orderby a
			       select a).Show();
        }
        static void Task38()
        {
			Console.WriteLine(@"LinqBegin38
Дана целочисленная последовательность A.
Получить новую последовательность чисел, элементы которой
определяются по соответствующим элементам последовательности
A следующим образом: если порядковый номер элемента A делится на 3 (3, 6, …),
то этот элемент в новую последовательность не включается;
если остаток от деления порядкового номера на 3 равен 1 (1, 4, …),
то в новую последовательность добавляется удвоенное значение этого элемента;
в противном случае (для элементов A с номерами 2, 5, …)
элемент добавляется в новую последовательность без изменений.
В полученной последовательности сохранить исходный
порядок следования элементов.
int[] A = { 3, 6, -4, 13, 18, 2, 5, 66, 33, 15 };");
			int[] A = { 3, 6, -4, 13, 18, 2, 5, 66, 33, 15 };
			A.Select((a, n) => n % 3 == 1 ? a * a : a).Where((a, n) => n % 3 != 0).Show();
        }
        static void Task39()
        {
			Console.WriteLine(@"LinqBegin39
Дана строковая последовательность A.
Получить последовательность цифровых символов,
входящих в строки последовательности A (символы могут повторяться).
Порядок символов должен соответствовать порядку строк A и
порядку следования символов в каждой строке.
Указание.Использовать метод SelectMany с учетом того, что
строка может интерпретироваться как последовательность символов.
string[] A = { ""gr56"", ""sg43"", ""543ds"", ""f4gh63"", ""fs345"" };");
			string[] A = { "gr56", "sg43", "543ds", "f4gh63", "fs345" };
			A.SelectMany(a => a.Where(Char.IsDigit)).Show();
        }
        static void Task40()
        {
			Console.WriteLine(@"LinqBegin40
Даны число K(> 0) и строковая последовательность A.
Получить последовательность символов, содержащую символы
всех строк из A, имеющих длину, большую или равную K(символы
могут повторяться). В полученной последовательности поменять
порядок элементов на обратный.
int K = 5;
string[] A = { ""gr56"", ""sg43"", ""543ds"", ""f4gh63"", ""fs345"" };");
			int K = 5;
			string[] A = { "gr56", "sg43", "543ds", "f4gh63", "fs345" };
			A.Where(a => a.Length >= K)
				.SelectMany(c => c)
				.Reverse()
				.Show();
        }
        static void Task41()
        {
			Console.WriteLine(@"LinqBegin41
Даны целое число K(> 0) и строковая последовательность A.
Каждый элемент последовательности представляет собой несколько слов
из заглавных латинских букв, разделенных символами «.» (точка).
Получить последовательность строк, содержащую все слова длины K
из элементов A в лексикографическом порядке по возрастанию (слова могут повторяться).
int K = 4;
string[] A = {""AS.SHOW"",""SNOW.BIG.DOGS"",""NOW"",""KNOW"",""GROUP.DROW"",""MOP"",""DIG"",""SHOW.FILM"",""KILL""};");
			int K = 4;
			string[] A = {
				"AS.SHOW",
				"SNOW.BIG.DOGS",
				"NOW",
				"KNOW",
				"GROUP.DROW",
				"MOP",
				"DIG",
				"SHOW.FILM",
				"KILL"
			};
			(from a in A.SelectMany(a => a.Split('.'))
			 where a.Length == K
			 orderby a
			 select a).Show();
        }
        static void Task42()
        {
			Console.WriteLine(@"LinqBegin42
Дана последовательность непустых строк. Получить
последовательность символов, которая определяется следующим
образом: для строк с нечетными порядковыми номерами (1, 3, …)
в последовательность символов включаются все прописные латинские буквы,
содержащиеся в этих строках, а для строк с четными номерами (2, 4, …) –
все их строчные латинские буквы.
В полученной последовательности символов сохранить их исходный порядок следования.
string[] A = { ""fRGcv"", ""fGRd"", ""DGgsD"", ""saefWWvs"" };");
			string[] A = { "fRGcv", "fGRd", "DGgsD", "saefWWvs" };
			A.SelectMany(( a, n) => (n + 1) % 2 == 1 ? a.Where(Char.IsUpper) : a.Where(Char.IsLower)).Show();
        }
        static void Task43()
        {
			Console.WriteLine(@"LinqBegin43
Даны целое число K(> 0) и последовательность непустых строк A.
Получить последовательность символов, которая определяется следующим образом:
для первых K элементов последовательности A в новую последовательность заносятся символы,
стоящие на нечетных позициях данной строки (1, 3, …), а для остальных
элементов A– символы на четных позициях (2, 4, …).
В полученной последовательности поменять порядок элементов на обратный.
Примечание.Решение данной задачи приведено в п. 5.4.
int k = 6;
var A = { ""jr"", ""r"", ""4RNV"", ""XqOA"", ""eZdZ"", ""QgAaq"", ""CbmL"", ""4x"", ""fCUud"", ""I"" };");
        	int k = 6;
        	string[] A = { "jr", "r", "4RNV", "XqOA", "eZdZ", "QgAaq", "CbmL", "4x", "fCUud", "I" };
        	A.Take(k).SelectMany(e => e.Where((c, i) => i % 2 == 0))
        		.Concat(A.Skip(k)
        		        .SelectMany(e => e.Where((c, i) => i % 2 == 1)))
        		.Reverse().Show();

        }

        //2.4. Объединение и группировка
        //Изучаемые запросы LINQ:
        //Concat (сцепление);
        //Join , GroupJoin (объединение);
        //DefaultIfEmpty (замена пустой последовательности на одноэлементную);
        //GroupBy (группировка).
        static void Task44()
        {
			Console.WriteLine(@"LinqBegin44
Даны целые числа K1 и K2 и целочисленные последовательности A и B.
Получить последовательность, содержащую все числа из A, большие K1,
и все числа из B, меньшие K2.
Отсортировать полученную последовательность по возрастанию.
int K1 = 5;
int K2 = 8;
int[] A = { -3, 4, 20, 2, 12, -5 };
int[] B = { -4, 12, 7, 3 };");
			int K1 = 5;
			int K2 = 8;
			int[] A = { -3, 4, 20, 2, 12, -5 };
			int[] B = { -4, 12, 7, 3 };
			A.Where(a => a > K1).Concat(B.Where(b => b < K2)).OrderBy(a => a).Show();
        }
        static void Task45()
        {
			Console.WriteLine(@"LinqBegin45
Даны целые положительные числа L1 и L2 и строковые последовательности A и B.
Строки последовательностей содержат только цифры и заглавные буквы латинского алфавита.
Получить последовательность, содержащую все строки из A длины L1 и все строки из B длины L2.
Отсортировать полученную последовательность в лексикографическом порядке по убыванию.
int L1 = 3;
int L2 = 4;
string[] A = { ""FD4"", ""54FD"", ""WMJR3"", ""3DC"" };
string[] B = { ""FSE5"", ""SCS"", ""6HGT"", ""WESRRW"", ""WD3H"" };");
			int L1 = 3;
			int L2 = 4;
			string[] A = { "FD4", "54FD", "WMJR3", "3DC" };
			string[] B = { "FSE5", "SCS", "6HGT", "WESRRW", "WD3H" };
			A.Where(a => a.Length == L1).Concat(B.Where(b => b.Length == L2)).OrderByDescending(a => a).Show();
        }
        static void Task46()
        {
            Console.WriteLine(@"LinqBegin46
Даны последовательности положительных целых чисел A и B;
все числа в каждой последовательности различны.
Найти последовательность всех пар чисел, удовлетворяющих следующим условиям:
первый элемент пары принадлежит последовательности A, второй принадлежит B,
и оба элемента оканчиваются одной и той же цифрой.
Результирующая последовательность называется внутренним объединением
последовательностей A и B по ключу, определяемому последними цифрами исходных чисел.
Представить найденное объединение в виде последовательности строк,
содержащих первый и второй элементы пары, разделенные дефисом,
например «49-129». Порядок следования пар должен определяться
исходным порядком элементов последовательности A, а для равных
первых элементов – порядком элементов последовательности B.
int[] A = { 5, 6, 8, 12, 43, 67, 876 };
int[] B = { 7, 9, 42, 11, 22, 54, 62 };");
            int[] A = { 5, 6, 8, 12, 43, 67, 876 };
            int[] B = { 7, 9, 42, 11, 22, 54, 62 };
            A.Join(B.OrderBy(b => b), a => a % 10, b => b % 10, (a, b) => a + "-" + b).Show();
        }
        static void Task47()
        {
        	Console.WriteLine(@"LinqBegin47
Даны последовательности положительных целых чисел A и B;
все числа в каждой последовательности различны.
Найти внутреннее объединение A и B(см. LinqBegin46),
пары в котором должны удовлетворять следующему условию:
последняя цифра первого элемента пары (из A) должна совпадать
с первой цифрой второго элемента пары (из B).
Представить найденное объединение в виде последовательности строк,
содержащих первый и второй элементы пары, разделенные двоеточием, например «49:921».
Порядок следования пар должен определяться исходным порядком
элементов последовательности A, а для равных первых элементов пар –
лексикографическим порядком строковых представлений вторых элементов (по возрастанию).
int[] A = { 5, 6, 8, 12, 43, 67, 876 };
int[] B = { 7, 9, 42, 11, 22, 54, 62 };");
        	int[] A = { 5, 6, 8, 12, 43, 67, 876 };
        	int[] B = { 7, 9, 42, 11, 22, 54, 62 };
            A.Select(a => a.ToString())
            	.Join(B.Select(b => b.ToString()).OrderBy(b => b),
                a => int.Parse(a) % 10,
                b => int.Parse(b[0].ToString()),
                (a, b) => a + ":" + b).Show();
        }
        static void Task48()
        {
			Console.WriteLine(@"LinqBegin48
Даны строковые последовательности A и B;
все строки в каждой последовательности различны, имеют ненулевую
длину и содержат только цифры и заглавные буквы латинского
алфавита. Найти внутреннее объединение A и B(см. LinqBegin46),
каждая пара которого должна содержать строки одинаковой длины.
Представить найденное объединение в виде последовательности
строк, содержащих первый и второй элементы пары, разделенные
двоеточием, например «AB:CD». Порядок следования пар должен
определяться лексикографическим порядком первых элементов пар
(по возрастанию), а для равных первых элементов – лексикографическим
порядком вторых элементов пар (по убыванию).
string[] A = { ""DEF5"", ""FSR"", ""FR"", ""5GDC"", ""TRN"" };
string[] B = { ""HTD"", ""SVHY"", ""IJ"", ""4"", ""FWSHG3"", ""EFS"" };");
			string[] A = { "DEF5", "FSR", "FR", "5GDC", "TRN" };
			string[] B = { "HTD", "SVHY", "IJ", "4", "FWSHG3", "EFS" };
			A.OrderBy(a=>a)
				.Join(B.OrderByDescending(b=>b),
				      a => a.Length,
				      b => b.Length,
				      (a, b) => a + ":" + b)
				.Show();
        }
        static void Task49()
        {
			Console.WriteLine(@"LinqBegin49
Даны строковые последовательности A, B и С;
все строки в каждой последовательности различны, имеют ненулевую
длину и содержат только цифры и заглавные буквы латинского алфавита.
Найти внутреннее объединение A, B и С(см. LinqBegin46),
каждая тройка которого должна содержать строки, начинающиеся
с одного и того же символа. Представить найденное объединение
в виде последовательности строк вида «EA=EB=EC», где EA, EB, EC –
элементы из A, B, C соответственно. Для различных элементов EA
сохраняется исходный порядок их следования, для равных элементов EA
порядок троек определяется лексикографическим порядком элементов EB
(по возрастанию), а для равных элементов EA и EB –
лексикографическим порядком элементов EC (по убыванию).
string[] A = { ""DEF5"", ""FSR"", ""FR"", ""5GDC"", ""TRN"" };
string[] B = { ""HTD"", ""DVHY"", ""IJ"", ""4"", ""FWSHG3"", ""EFS"" };
string[] C = { ""GTDCV"", ""F5HYU"", ""DFRNH"", ""LIJ6"", ""DSR"" };");
			string[] A = { "DEF5", "FSR", "FR", "5GDC", "TRN" };
			string[] B = { "HTD", "DVHY", "IJ", "4", "FWSHG3", "EFS" };
			string[] C = { "GTDCV", "F5HYU", "DFRNH", "LIJ6", "DSR" };
			A.Join(
				B.OrderBy(b => b)
				.Join(C.OrderByDescending(c => c),
					b => b[0],
					c => c[0],
					(b, c) => b + ":" + c),
				a => a[0],
				b => b[0],
				(a, b) => a + ":" + b)
				.Show();
        }
        static void Task50()
        {
			Console.WriteLine(@"LinqBegin50
Даны строковые последовательности A и B; все
строки в каждой последовательности различны и имеют ненулевую
длину. Получить последовательность строк вида «E:N»,
где E обозначает один из элементов последовательности A, а N–количество
элементов из B, начинающихся с того же символа, что и элемент
E(например, «abc:4»); количество N может быть равно 0. Порядок
элементов полученной последовательности должен определяться
исходным порядком элементов последовательности A.
Указание.Использовать метод GroupJoin.
string[] A = { ""DEF5"", ""FSR"", ""FR"", ""5GDC"", ""TRN"" };
string[] B = { ""DTD"", ""DVHY"", ""DJ"", ""5"", ""FWSHG3"", ""5EFS"" };");
			string[] A = { "DEF5", "FSR", "FR", "5GDC", "TRN" };
			string[] B = { "DTD", "DVHY", "DJ", "5", "FWSHG3", "5EFS" };
			A.GroupJoin(
				B,
				a => a[0],
				b => b[0],
				(a, b) => a + ":" + b.Count())
				.Show();
        }
        static void Task51()
        {
			Console.WriteLine(@"LinqBegin51
Даны последовательности положительных целых
чисел A и B; все числа в последовательности A различны. Получить
последовательность строк вида «S:E», где S обозначает сумму тех
чисел из B, которые оканчиваются на ту же цифру, что и число E–
один из элементов последовательности A (например, «74:23»); если
для числа E не найдено ни одного подходящего числа из последовательности B,
то в качестве S указать 0. Расположить элементы полученной последовательности
по возрастанию значений найденных сумм, а при равных суммах –
по убыванию значений элементов A.
int[] A = { 34, 1, 65, 342, 75, 43, 45, 21, 12, 52, 6 };
int[] B = { 4, 53, 54, 12, 57, 43, 13, 2, 3, 75, 105, 10, 18, 11, 1 };");
			int[] A = { 34, 1, 65, 342, 75, 43, 45, 21, 12, 52, 6 };
			int[] B = { 4, 53, 54, 12, 57, 43, 13, 2, 3, 75, 105, 10, 18, 11, 1 };
			A.OrderByDescending(a => a)
				.GroupJoin(B,
				a => a % 10,
				b => b % 10,
				(a, b) => b.Sum() + ":" + a)
				.OrderBy(a => Int32.Parse(a.Split(':')[0]))
				.Show();
        }
        static void Task52()
        {
			Console.WriteLine(@"LinqBegin52
Даны строковые последовательности A и B; все
строки в каждой последовательности различны, имеют ненулевую
длину и содержат только цифры и заглавные буквы латинского алфавита.
Получить последовательность всевозможных комбинаций вида «EA=EB», где EA
– некоторый элемент из A, EB – некоторый элемент из B,
причем оба элемента оканчиваются цифрой (например, «AF3=D78»).
Упорядочить полученную последовательность в лексикографическом порядке
по возрастанию элементов EA, а при одинаковых элементах EA
– в лексикографическом порядке по убыванию элементов EB.
Указание.Для перебора комбинаций использовать методы Select Many и Select.
Примечание.Решение данной задачи приведено в п. 5.5.2.
string[] A = { ""AJ"", ""HE9"", ""0"", ""J2"", ""B7"", ""DBH"", ""D"", ""CGH"", ""2"", ""D2C"", ""4"", ""1"", ""5DD"", ""B"", ""2A7"" };
string[] B = { ""EJ"", ""1"", ""BG"", ""7IB"", ""E"", ""F"", ""J"", ""2"", ""0"", ""1I9"" };");
			string[] A = { "AJ", "HE9", "0", "J2", "B7", "DBH", "D", "CGH", "2", "D2C", "4", "1", "5DD", "B", "2A7" };
			string[] B = { "EJ", "1", "BG", "7IB", "E", "F", "J", "2", "0", "1I9" };
			A.Where(e => char.IsDigit(e.Last()))
				.OrderBy(e => e)
				.SelectMany(e1 => B
				            .Where(e => char.IsDigit(e.Last()))
				            .OrderByDescending(e => e)
				            .Select(e2 => e1 + "=" + e2))
				.Show();
        }
        static void Task53()
        {
			Console.WriteLine(@"LinqBegin53
Даны целочисленные последовательности A и B.
Получить последовательность всех различных сумм, в которых первое
слагаемое берется из A, а второе – из B. Упорядочить полученную
последовательность по возрастанию.
int[] A = { 5, 12, -4, 15, 32, 5, 3 };
int[] B = { 5, 3, -5, -7, 0, 12, 7 };");
			int[] A = { 5, 12, -4, 15, 32, 5, 3 };
			int[] B = { 5, 3, -5, -7, 0, 12, 7 };
			A.SelectMany(a => B.Select(b => a + b)).OrderBy(a => a).Show();
        }
        static void Task54()
        {
			Console.WriteLine(@"LinqBegin54
Даны строковые последовательности A и B; все
строки в каждой последовательности различны, имеют ненулевую
длину и содержат только цифры и заглавные буквы латинского алфавита.
Найти последовательность всех пар строк, удовлетворяющих следующим условиям:
первый элемент пары принадлежит последовательности A,
а второй либо является одним из элементов последовательности B,
начинающихся с того же символа, что и первый элемент пары,
либо является пустой строкой (если B не содержит ни одной подходящей строки).
Результирующая последовательность называется левым внешним объединением
последовательностей A и B по ключу, определяемому первыми символами исходных строк.
Представить найденное объединение в виде последовательности строк вида «EA.EB», где EA
– элемент из A, а EB – либо один из соответствующих ему элементов из B, либо пустая строка.
Расположить элементы полученной строковой последовательности в лексикографическом порядке по возрастанию.
Указание.Использовать методы GroupJoin, DefaultIfEmpty, Select и SelectMany.
Примечание.Решение данной задачи приведено в п. 5.5.4.
string[] A = { ""AJ"", ""HE9"", ""0"", ""J2"", ""B7"", ""DBH"", ""D"", ""CGH"", ""2"", ""D2C"", ""4"", ""1"", ""5DD"", ""B"", ""2A7"" };
string[] B = { ""EJ"", ""1"", ""BG"", ""7IB"", ""E"", ""F"", ""J"", ""2"", ""0"", ""1I9"" };");
			string[] A = { "AJ", "HE9", "0", "J2", "B7", "DBH", "D", "CGH", "2", "D2C", "4", "1", "5DD", "B", "2A7" };
			string[] B = { "EJ", "1", "BG", "7IB", "E", "F", "J", "2", "0", "1I9" };
			(from e1 in A
			 join e2 in B
			 on e1[0] equals e2[0]
			 into ee2
			 from e in ee2.DefaultIfEmpty("")
			 let r = e1 + "." + e
			 orderby r
			 select r).Show();
        }
        static void Task55()
        {
			Console.WriteLine(@"LinqBegin55
Даны последовательности положительных целых
чисел A и B; все числа в каждой последовательности различны.
Найти левое внешнее объединение A и B(см. LinqBegin54),
пары в котором должны удовлетворять следующему условию: оба элемента
пары оканчиваются одной и той же цифрой. Представить найденное
объединение в виде последовательности строк вида «EA:EB», где EA – число из A,
а EB – либо одно из соответствующих ему чисел из B, либо 0
(если в B не содержится чисел, соответствующих EA).
Расположить элементы полученной последовательности по убыванию чисел EA,
а при одинаковых числах EA – по возрастанию чисел EB.
int[] A = { 35, 16, 17, 5, 54, 12 };
int[] B = { 24, 15, 77, 7, 14, 2, 22 };");
			int[] A = { 35, 16, 17, 5, 54, 12 };
			int[] B = { 24, 15, 77, 7, 14, 2, 22 };
			(from e1 in A
			 join e2 in B
			 on e1%10 equals e2%10
			 into ee
			 from e in ee.DefaultIfEmpty(0)
			 let r = e1+":"+e
			 orderby e1 descending, e
			 select r).Show();
        }
        static void Task56()
        {
			Console.WriteLine(@"LinqBegin56
Дана целочисленная последовательность A.
Сгруппировать элементы последовательности A, оканчивающиеся одной
и той же цифрой, и на основе этой группировки получить последовательность
строк вида «D:S», где D– ключ группировки(то есть некоторая цифра,
которой оканчивается хотя бы одно из чисел последовательности A),
а S– сумма всех чисел из A, которые оканчиваются цифрой D.
Полученную последовательность упорядочить по возрастанию ключей.
Указание.Использовать метод GroupBy.
int[] A = { 24, 15, 77, 7, 14, 2, 22 };");
			int[] A = { 24, 15, 77, 7, 14, 2, 22 };
			(from a in A
			 group a by a % 10 into e
			 orderby e.Key
			 select e.Key + ":" + e.Sum()).Show();
			//A.GroupBy(a => a % 10).OrderBy(a=>a.Key).Select(a=>a.Key+":"+a.Sum()).Show(); 
        }
        static void Task57()
        {
			Console.WriteLine(@"LinqBegin57
Дана целочисленная последовательность.
Среди всех элементов последовательности, оканчивающихся одной и той
же цифрой, выбрать максимальный. Полученную последовательность максимальных
элементов упорядочить по возрастанию их последних цифр.
int[] A = { 24, 15, 77, 7, 14, 2, 22 };");
        	int[] A = { 24, 15, 77, 7, 14, 2, 22 };
        	(from a in A
        	 group a by a%10 into e
        	 orderby e.Max()%10
        	 select e.Max()
        	 ).Show();
        }
        static void Task58()
        {
			Console.WriteLine(@"LinqBegin58
Дана последовательность непустых строк.
Среди всех строк, начинающихся с одного и того же символа, выбрать наиболее длинную.
Если таких строк несколько, то выбрать первую по порядку их следования в
исходной последовательности. Полученную последовательность строк упорядочить
по возрастанию кодов их начальных символов.
string[] A = { ""AJ"", ""HE9"", ""50"", ""J2"", ""J53g7"", ""DBH"", ""D"", ""CGH"", ""2"", ""D2Cfds"", ""4"", ""1"", ""5DD"", ""H"", ""2A7"" };");
			string[] A = { "AJ", "HE9", "50", "J2", "J53g7", "DBH", "D", "CGH", "2", "D2Cfds", "4", "1", "5DD", "H", "2A7" };
			(from a in A
			 orderby a.Length descending
			 group a by a.First() into a
			 select a.ElementAt(0) into a
			 orderby a[0]
			 select a)
				.Show();	 
        }
        static void Task59()
        {
			Console.WriteLine(@"LinqBegin59
Дана последовательность непустых строк, содержащих только
заглавные буквы латинского алфавита. Среди всех строк одинаковой длины
выбрать первую в лексикографическом порядке (по возрастанию).
Полученную последовательность строк упорядочить по убыванию их длин.
string[] A = { ""AJ"", ""HE9"", ""50"", ""J2"", ""J53g7"", ""DBH"", ""D"", ""CGH"", ""2"", ""D2Cfds"", ""4"", ""1"", ""5DD"", ""H"", ""2A7"" };");
			string[] A = { "AJ", "HE9", "50", "J2", "J53G7", "DBH", "D", "CGH", "2", "D2Cfds", "4", "1", "5DD", "H", "2A7" };
			(from a in A
			       orderby a
			       group a by a.Length into a
			       select a.ElementAt(0) into a
			       orderby a.Length descending
			       select a).Show();
        }
        static void Task60()
        {
			Console.WriteLine(@"LinqBegin60
Дана последовательность непустых строк A, содержащих только заглавные
буквы латинского алфавита. Для всех строк, начинающихся с одной и той же буквы,
определить их сум-марную длину и получить последовательность строк вида «S-C», где
S– суммарная длина всех строк из A, которые начинаются с буквы С.
Полученную последовательность упорядочить по убыванию числовых значений сумм,
а при равных значениях сумм – по возрас-танию кодов символов C.
Примечание.Решение данной задачи приведено в п. 5.6.
string[] el = { ""QWJ"", ""OGS"", ""DA"", ""HHCO"", ""SXZ"", ""B"", ""SPPM"", ""YHBR"", ""OPLU"", ""JY"", ""ZOFX"", ""ODMQF"", ""ZAFK"", ""WJBQ"" };");
        	string[] el = { "QWJ", "OGS", "DA", "HHCO", "SXZ", "B", "SPPM", "YHBR", "OPLU", "JY", "ZOFX", "ODMQF", "ZAFK", "WJBQ" };
        	(from e in el
        	 group e.Length by e[0]
        	 into r
        	 let s = r.Sum()
        	 let k = r.Key
        	 orderby s descending, k
        	 select s + "-" + k).Show();
        }
        public static void Main(string[] args)
        {
            string N;
            do
            {
                Console.Write("\n\nInput task (0 - to exit, 99 - to all tasks): ");
                N = Console.ReadLine();
                //Получаем методы
                MethodInfo[] MI = typeof(Program).GetMethods(BindingFlags.Static | BindingFlags.NonPublic);
                //Показываем их
                try
                {
                	if(N=="99")
                	{
                		//Запускаем все методы Task
                		foreach (MethodInfo m in MI.Where(a=>a.Name.StartsWith("Task"))) {
                			m.Invoke(null, null);
							Console.WriteLine("\n");
						}
                	} else {
						//Выбираем метод который нам нужен по имени
						MethodInfo method = MI.First(a => a.Name == "Task" + N);
						//Вызываем его
						method.Invoke(null, null);
					}
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.Message);
                }
            } while (N != "0");
            Console.WriteLine("\n\n");
        }
    }
}
