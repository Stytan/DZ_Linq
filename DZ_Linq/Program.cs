/*
 * Created by SharpDevelop.
 * User: sergey.lezhenko
 * Date: 04.09.2017
 * Time: 10:54
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
using System;
using System.Collections;
using System.Linq;
using System.Text;

namespace DZ_LINQ
{
    public static class ExMethods
    {
        public static void Show(this IEnumerable seq)
        {
            IEnumerator el = seq.GetEnumerator();
            while (el.MoveNext())
            {
                Console.Write(el.Current + " ");
            }
        }
        public static void Show(this object el)
        {
            Console.Write(el.ToString() + " ");
        }
    }
    class Program
    {

        public static void Main(string[] args)
        {


            /*LinqBegin1.Дана целочисленная последовательность, содержащая 
			как положительные, так и отрицательные числа. Вывести ее первый 
			положительный элемент и последний отрицательный элемент. */
            {
                Console.WriteLine("LinqBegin1");
                int[] e = { 4, 12, -6, -4, -32, 47, 32, 96, 0, 23, -5, -3, -75, 15 };
                e.FirstOrDefault(a => a > 0).Show();
                e.LastOrDefault(a => a < 0).Show();
                Console.WriteLine("\n");
            }
            //LinqBegin2.Даны цифра D (однозначное целое число) и целочисленная последовательность A.
            //Вывести первый положительный элемент последовательности A, оканчивающийся цифрой  D.
            //Если требуемых элементов в последовательности A нет, то вывести 0.
            {
                Console.WriteLine("LinqBegin2");
                int D = 2;
                int[] A = { 4, 12, -6, -4, -32, 47, 32, 96, 0, 23, -5, -3, -75, 15 };
                A.FirstOrDefault(r => r > 0 && r.ToString().EndsWith(D.ToString(), StringComparison.CurrentCulture)).Show();
                Console.WriteLine("\n");
            }

            //LinqBegin3.Даны целое число L(> 0) и строковая последовательность A.
            //Вывести последнюю строку из A, начинающуюся с цифры
            //и имеющую длину L. Если требуемых строк в последовательности
            //A нет, то вывести строку «Not found».
            //Указание.Для обработки ситуации, связанной с отсутствием требуемых строк, использовать операцию ??.
            {
                Console.WriteLine("LinqBegin3");
                int L = 4;
                string[] A = { "8pOl", "", "OOHNG", "2J", "jle", "ojRa", "UTq", "4A3", "", "bh", "p", "daW" };
                Console.Write(A.LastOrDefault(r => r.Length == L && r.IndexOfAny(new[] {
                             '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' }) == 0) ?? "Not found");
                Console.WriteLine("\n");
            }

            //LinqBegin4.Даны символ С и строковая последовательность A.
            //Если A содержит единственный элемент, оканчивающийся символом C,
            //то вывести этот элемент; если требуемых строк в A нет, то
            //вывести пустую строку; если требуемых строк больше одной, то вывести строку «Error».
            //Указание.Использовать try-блок для перехвата возможного исключения.
            //Примечание.Решение данной задачи приведено в п. 5.1.
            {
                Console.WriteLine("LinqBegin4:");
                const char c = 'l';
                string[] A = { "8pOvl", "", "OOHNG", "2J", "jle", "ojRa", "UTq", "4A3", "", "bh", "p", "daW" };
                try
                {
                    Console.Write(A.SingleOrDefault(e => e.Length != 0 && e[e.Length - 1] == c) ?? "");
                }
                catch
                {
                    Console.Write("Error");
                }
                Console.WriteLine("\n");
            }
            //LinqBegin5.Даны символ С и строковая последовательность A.
            //Найти количество элементов A, которые содержат более одного
            //символа и при этом начинаются и оканчиваются символом C.
            {
                Console.WriteLine("LinqBegin5");
                char C = 'O';
                string[] A = { "8pOl", "", "OOHNGO", "2J", "OjleO", "ojRa", "OUOTq", "4A3", "", "bh", "p", "daW" };
                Console.Write(A.Count(r => r.Length > 1
                                      && r.StartsWith(C.ToString(), StringComparison.Ordinal)
                                      && r.EndsWith(C.ToString(), StringComparison.Ordinal))
                                     );
                Console.WriteLine("\n");
            }

            //LinqBegin6.Дана строковая последовательность. Найти сумму
            //длин всех строк, входящих в данную последовательность.


            //LinqBegin7.Дана целочисленная последовательность.
            //Найти ко-личество ее отрицательных элементов,
            //а также их сумму.
            //Если от-рицательные элементы отсутствуют, то дважды вывести 0.


            //LinqBegin8.Дана целочисленная последовательность. Найти
            //ко личество ее положительных двузначных элементов, а также их
            //среднее арифметическое (как вещественное число). Если требуемые
            //элементы отсутствуют, то дважды вывести 0 (первый раз как целое,
            //второй – как вещественное).


            //LinqBegin9.Дана целочисленная последовательность. Вывести ее
            //минимальный положительный элемент или число 0,
            //если последовательность не содержит положительных элементов.

            //LinqBegin10.Даны целое число L(> 0) и строковая последова-тельность A.
            //Строки последовательности A содержат только заглавные буквы латинского алфавита.
            //Среди всех строк из A, имеющих длину L, найти наибольшую (в смысле лексикографического по-рядка).
            //Вывести эту строку или пустую строку, если последовательность не содержит строк длины L.


            //LinqBegin11.Дана последовательность непустых строк.
            //Исполь-зуя метод Aggregate, получить строку, состоящую из
            //начальных сим-волов всех строк исходной последовательности.


            //LinqBegin12.Дана целочисленная последовательность.
            //Используя метод Aggregate, найти произведение последних цифр
            //всех элементов последовательности.
            //Чтобы избежать целочисленного переполнения,
            //при вычислении произведения использовать веществен-ный числовой тип.

            //LinqBegin13.Дано целое число N (> 0). Используя методы Range
            //и Sum, найти сумму 1 + (1/2) + … + (1/N) (как вещественное число).

            //LinqBegin14.Даны целые числа A и B(A< B).
            //Используя мето-ды Range и Average, найти среднее арифметическое квадратов всех
            //целых чисел от A до B включительно: (A^2 + (A + 1)^2 + … + B^2)/(B – A + 1) (как вещественное число).

            //LinqBegin15.Дано целое число N(0 <= N <= 15). Используя методы Range и Aggregate,
            //найти факториал числа N: N! = 1·2·…·N при N >= 1; 0! = 1.
            //Чтобы избежать целочисленного переполнения, при
            //вычислении факториала использовать вещественный числовой тип.
            //Примечание.Решение данной задачи приведено в п. 5.2.
            Console.WriteLine("LinqBegin15:");
            const int N = 5;
            Console.Write(Enumerable.Range(1, N).Aggregate(1.0, (a, e) => a * e));
            Console.WriteLine("\n");

            //2.2. Фильтрация, сортировка,
            //теоретико-множественные операции
            //Изучаемые запросы LINQ:
            //Where , TakeWhile , SkipWhile , Take , Skip (фильтрация);
            //OrderBy , OrderByDescending , ThenBy , ThenByDescending (сор-тировка);
            //Distinct , Reverse (удаление повторяющихся элементов и ин-вертирование);
            //Union , Intersect , Except (теоретико-множественные операции)

            //LinqBegin16.Дана целочисленная последовательность. Извлечь
            //из нее все положительные числа, сохранив их исходный порядок
            //следования.

            //LinqBegin17.Дана целочисленная последовательность. Извлечь
            //из нее все нечетные числа, сохранив их исходный порядок следо-вания
            //и удалив все вхождения повторяющихся элементов, кроме первых.

            //LinqBegin18.Дана целочисленная последовательность. Извлечь
            //из нее все четные отрицательные числа,
            //поменяв порядок извлечен-ных чисел на обратный.

            //LinqBegin19.Даны цифра D(целое однозначное число) и целочисленная
            //последовательность A. Извлечь из A все различные положительные числа,
            //оканчивающиеся цифрой D(в исходном порядке).
            //При наличии повторяющихся элементов удалять все их вхождения, кроме последних.
            //Указание.Последовательно применить методы Reverse, Distinct, Reverse.

            //LinqBegin20.Дана целочисленная последовательность. Извлечь
            //из нее все положительные двузначные числа, отсортировав их по возрастанию.

            //LinqBegin21.Дана строковая последовательность.
            //Строки последовательности содержат только заглавные буквы латинского
            //алфавита. Отсортировать последовательность по возрастанию длин
            //строк, а строки одинаковой длины – в лексикографическом порядке
            //по убыванию.

            //LinqBegin22.Даны целое число K(> 0) и строковая последовательность A.
            //Строки последовательности содержат только цифры
            //и заглавные буквы латинского алфавита. Извлечь из A все строки
            //длины K, оканчивающиеся цифрой, отсортировав их в лексикографическом порядке по возрастанию.

            //LinqBegin23.Даны целое число K(> 0) и целочисленная после-довательность A.
            //Начиная с элемента A с порядковым номером K,
            //извлечь из A все нечетные двузначные числа, отсортировав их по убыванию.

            //LinqBegin24.Даны целое число K(> 0) и строковая последовательность A.
            //Из элементов A, предшествующих элементу с порядковым номером K,
            //извлечь те строки, которые имеют нечетную длину и начинаются с заглавной латинской буквы,
            //изменив порядок сле-дования извлеченных строк на обратный.

            //LinqBegin25.Даны целые числа K1 и K2 и целочисленная после-довательность A;
            //1 <= K1 < K2 <= N, где N–размер последовательности A.
            //Найти сумму положительных элементов последовательности
            //с порядковыми номерами от K1 до K2 включительно.

            //LinqBegin26.Даны целые числа K1 и K2 и последовательность непустых строк A;
            //1 < K1 < K2 <= N, где N–размер последовательности A.
            //Найти среднее арифметическое длин всех элементов последовательности,
            //кроме элементов с порядковыми номерами от K1 до K2
            //включительно, и вывести его как вещественное число.

            //LinqBegin27.Даны целое число D и целочисленная последовательность A.
            //Начиная с первого элемента A, большего D, извлечь из
            //A все нечетные положительные числа, поменяв порядок извлеченных чисел на обратный.

            //LinqBegin28.Даны целое число L(> 0) и последовательность непустых строк A.
            //Строки последовательности содержат только цифры и заглавные буквы латинского алфавита.
            //Из элементов A, предшествующих первому элементу, длина которого превышает L, извлечь
            //строки, оканчивающиеся буквой. Полученную последовательность
            //отсортировать по убыванию длин строк, а строки одинаковой длины –
            //в лексикографическом порядке по возрастанию.

            //LinqBegin29.Даны целые числа D и K(K> 0) и целочисленная последовательность A.
            //Найти теоретико-множественное объединение двух фрагментов A:
            //первый содержит все элементы до первого элемента, большего D(не включая его),
            //а второй – все элементы, начиная с элемента с порядковым номером K.
            //Полученную последовательность (не содержащую одинаковых элементов) отсортировать по убыванию.

            //LinqBegin30.Даны целое число K(> 0) и целочисленная последовательность A.
            //Найти теоретико-множественную разность двух фрагментов A:
            //первый содержит все четные числа, а второй – все числа с порядковыми номерами, большими K.
            //В полученной последовательности (не содержащей одинаковых элементов) поменять
            //порядок элементов на обратный.

            //LinqBegin31.Даны целое число K(> 0) и последовательность
            //непустых строк A. Строки последовательности содержат только
            //цифры и заглавные буквы латинского алфавита.
            //Найти теоретико-множественное пересечение двух фрагментов A: первый содержит
            //K начальных элементов, а второй – все элементы, расположенные
            //после последнего элемента, оканчивающегося цифрой. Полученную
            //последовательность (не содержащую одинаковых элементов) отсортировать
            //по возрастанию длин строк, а строки одинаковой длины –
            //в лексикографическом порядке по возрастанию.
            //Примечание. Решение данной задачи приведено в п. 5.3

            //2.3. Проецирование
            //Изучаемые запросы LINQ:
            //Select , SelectMany (проецирование).

            //LinqBegin32.Дана последовательность непустых строк A.
            //Получить последовательность символов, каждый элемент которой
            //является начальным символом соответствующей строки из A.
            //Порядок символов должен быть обратным по отношению к порядку
            //элементов исходной последовательности.

            //LinqBegin33.Дана целочисленная последовательность.
            //Обрабатывая только положительные числа, получить последовательность
            //их последних цифр и удалить в полученной последовательности все
            //вхождения одинаковых цифр, кроме первого. Порядок полученных
            //цифр должен соответствовать порядку исходных чисел.

            //LinqBegin34.Дана последовательность положительных целых чисел.
            //Обрабатывая только нечетные числа, получить последовательность
            //их строковых представлений и отсортировать ее в лексикографическом порядке по возрастанию.

            //LinqBegin35.Дана целочисленная последовательность. Получить
            //последовательность чисел, каждый элемент которой равен произведению
            //соответствующего элемента исходной последовательности на
            //его порядковый номер (1, 2, …). В полученной последовательности
            //удалить все элементы, не являющиеся двузначными,
            //и поменять порядок оставшихся элементов на обратный.

            //LinqBegin36.Дана последовательность непустых строк. Получить
            //последовательность символов, которая определяется следующим об-разом:
            //если соответствующая строка исходной последовательности
            //имеет нечетную длину, то в качестве символа берется первый символ
            //этой строки; в противном случае берется последний символ строки.
            //Отсортировать полученные символы по убыванию их кодов.

            //LinqBegin37.Дана строковая последовательность A.
            //Строки последовательности содержат только заглавные буквы латинского алфавита.
            //Получить новую последовательность строк, элементы которой определяются
            //по соответствующим элементам A следующим образом:
            //пустые строки в новую последовательность не включаются,
            //а к непустым приписывается порядковый номер данной строки
            //в исходной последовательности (например, если пятый элемент A имеет
            //вид «ABC», то в полученной последовательности он будет иметь
            //вид «ABC5»). При нумерации должны учитываться и пустые строки
            //последовательности A. Отсортировать полученную последовательность
            //в лексикографическом порядке по возрастанию.

            //LinqBegin38.Дана целочисленная последовательность A.
            //Получить новую последовательность чисел, элементы которой
            //определяются по соответствующим элементам последовательности
            //A следующим образом: если порядковый номер элемента A делится на 3 (3, 6, …),
            //то этот элемент в новую последовательность не включается;
            //если остаток от деления порядкового номера на 3 равен 1 (1, 4, …),
            //то в новую последовательность добавляется удвоенное значение этого элемента;
            //в противном случае (для элементов A с номерами 2, 5, …)
            //элемент добавляется в новую последовательность без изменений.
            //В полученной последовательности сохранить исходный
            //порядок следования элементов.

            //LinqBegin39.Дана строковая последовательность A.
            //Получить последовательность цифровых символов,
            //входящих в строки последовательности A (символы могут повторяться).
            //Порядок символов должен соответствовать порядку строк A и
            //порядку следования символов в каждой строке.
            //Указание.Использовать метод SelectMany с учетом того, что
            //строка может интерпретироваться как последовательность символов.

            //LinqBegin40.Даны число K(> 0) и строковая последовательность A.
            //Получить последовательность символов, содержащую символы
            //всех строк из A, имеющих длину, большую или равную K(символы
            //могут повторяться). В полученной последовательности поменять
            //порядок элементов на обратный.

            //LinqBegin41.Даны целое число K(> 0) и строковая последовательность A.
            //Каждый элемент последовательности представляет собой несколько слов
            //из заглавных латинских букв, разделенных символами «.» (точка).
            //Получить последовательность строк, содержащую все слова длины K
            //из элементов A в лексикографическом порядке по возрастанию (слова могут повторяться).

            //LinqBegin42.Дана последовательность непустых строк. Получить
            //последовательность символов, которая определяется следующим
            //образом: для строк с нечетными порядковыми номерами (1, 3, …)
            //в последовательность символов включаются все прописные латинские буквы,
            //содержащиеся в этих строках, а для строк с четными номерами (2, 4, …) –
            //все их строчные латинские буквы.
            //В полученной последовательности символов сохранить их исходный порядок следования.

            //LinqBegin43.Даны целое число K(> 0) и последовательность непустых строк A.
            //Получить последовательность символов, которая определяется следующим образом:
            //для первых K элементов последовательности A в новую последовательность заносятся символы,
            //стоящие на нечетных позициях данной строки (1, 3, …), а для остальных
            //элементов A– символы на четных позициях (2, 4, …).
            //В полученной последовательности поменять порядок элементов на обратный.
            //Примечание.Решение данной задачи приведено в п. 5.4.

            //2.4. Объединение и группировка
            //Изучаемые запросы LINQ:
            //Concat (сцепление);
            //Join , GroupJoin (объединение);
            //DefaultIfEmpty (замена пустой последовательности на одно-элементную);
            //GroupBy (группировка).

            //LinqBegin44.Даны целые числа K1 и K2 и целочисленные последовательности A и B.
            //Получить последовательность, содержащую все числа из A, большие K1,
            //и все числа из B, меньшие K2.
            //Отсортировать полученную последовательность по возрастанию.

            //LinqBegin45.Даны целые положительные числа L1 и L2 и строковые последовательности A и B.
            //Строки последовательностей содержат только цифры и заглавные буквы латинского алфавита.
            //Получить последовательность, содержащую все строки из A длины L1 и все строки из B длины L2.
            //Отсортировать полученную последовательность в лексикографическом порядке по убыванию.

            //LinqBegin46.Даны последовательности положительных целых чисел Aи B;
            //все числа в каждой последовательности различны.
            //Найти последовательность всех пар чисел, удовлетворяющих следующим условиям:
            //первый элемент пары принадлежит последовательности A, второй принадлежит B,
            //и оба элемента оканчиваются одной и той же цифрой.
            //Результирующая последовательность называется внутренним объединением
            //последовательностей A и B по ключу, определяемому последними цифрами исходных чисел.
            //Представить найденное объединение в виде последовательности строк,
            //содержащих первый и второй элементы пары, разделенные дефисом,
            //например «49-129». Порядок следования пар должен определяться
            //исходным порядком элементов последовательности A, а для равных
            //первых элементов – порядком элементов последовательности B.

            //LinqBegin47.Даны последовательности положительных целых
            //чисел A и B; все числа в каждой последовательности различны.
            //Найти внутреннее объединение A и B(см. LinqBegin46),
            //пары в котором должны удовлетворять следующему условию:
            //последняя цифра первого элемента пары (из A) должна совпадать
            //с первой цифрой второго элемента пары (из B).
            //Представить найденное объединение в виде последовательности строк,
            //содержащих первый и второй элементы пары, разделенные двоеточием,
            //например «49:921». Порядок следования пар должен определяться исходным порядком
            //элементов последовательности A, а для равных первых элементов пар –
            //лексикографическим порядком строковых представлений вторых элементов (по возрастанию).

            //LinqBegin48.Даны строковые последовательности A и B; все
            //строки в каждой последовательности различны, имеют ненулевую
            //длину и содержат только цифры и заглавные буквы латинского
            //алфавита. Найти внутреннее объединение A и B(см. LinqBegin46),
            //каждая пара которого должна содержать строки одинаковой длины.
            //Представить найденное объединение в виде последовательности
            //строк, содержащих первый и второй элементы пары, разделенные
            //двоеточием, например «AB:CD». Порядок следования пар должен
            //определяться лексикографическим порядком первых элементов пар
            //(по возрастанию), а для равных первых элементов – лексикографическим
            //порядком вторых элементов пар (по убыванию).

            //LinqBegin49.Даны строковые последовательности A, Bи С;
            //все строки в каждой последовательности различны, имеют ненулевую
            //длину и содержат только цифры и заглавные буквы латинского алфавита.
            //Найти внутреннее объединение A, B и С(см. LinqBegin46),
            //каждая тройка которого должна содержать строки, начинающиеся
            //с одного и того же символа. Представить найденное объединение
            //в виде последовательности строк вида «EA=EB=EC», где EA, EB, EC –
            //элементы из A, B, C соответственно. Для различных элементов EA
            //сохраняется исходный порядок их следования, для равных элементов EA
            //порядок троек определяется лексикографическим порядком элементов EB
            //(по возрастанию), а для равных элементов EA и EB –
            //лексикографическим порядком элементов EC (по убыванию).

            //LinqBegin50.Даны строковые последовательности Aи B; все
            //строки в каждой последовательности различны и имеют ненулевую
            //длину. Получить последовательность строк вида «E:N»,
            //где E обозначает один из элементов последовательности A, а N–количество
            //элементов из B, начинающихся с того же символа, что и элемент
            //E(например, «abc:4»); количество N может быть равно 0. Порядок
            //элементов полученной последовательности должен определяться
            //исходным порядком элементов последовательности A.
            //Указание.Использовать метод GroupJoin.

            //LinqBegin51.Даны последовательности положительных целых
            //чисел A и B; все числа в последовательности Aразличны. Получить
            //последовательность строк вида «S:E», где S обозначает сумму тех
            //чисел из B, которые оканчиваются на ту же цифру, что и число E–
            //один из элементов последовательности A (например, «74:23»); если
            //для числа E не найдено ни одного подходящего числа из последовательности B,
            //то в качестве S указать 0. Расположить элементы полученной последовательности
            //по возрастанию значений найденных сумм, а при равных суммах –
            //по убыванию значений элементов A.

            //LinqBegin52.Даны строковые последовательности Aи B; все
            //строки в каждой последовательности различны, имеют ненулевую
            //длину и содержат только цифры и заглавные буквы латинского алфавита.
            //Получить последовательность всевозможных комбинаций вида «EA=EB», где EA
            //– некоторый элемент из A, EB – некоторый элемент из B,
            //причем оба элемента оканчиваются цифрой (например, «AF3=D78»).
            //Упорядочить полученную последовательность в лексикографическом порядке
            //по возрастанию элементов EA, а при одинаковых элементах EA
            //– в лексикографическом порядке по убыванию элементов EB.
            //Указание.Для перебора комбинаций использовать методы Select Many и Select.
            //Примечание.Решение данной задачи приведено в п. 5.5.2.

            //LinqBegin53.Даны целочисленные последовательности A и B.
            //Получить последовательность всех различныхсумм, в которых первое
            //слагаемое берется из A, а второе – из B. Упорядочить полученную
            //последовательность по возрастанию.

            //LinqBegin54.Даны строковые последовательности A и B; все
            //строки в каждой последовательности различны, имеют ненулевую
            //длину и содержат только цифры и заглавные буквы латинского алфавита.
            //Найти последовательность всех пар строк, удовлетворяющих следующим условиям:
            //первый элемент пары принадлежит последовательности A,
            //а второй либо является одним из элементов последовательности B,
            //начинающихся с того же символа, что и первый элемент пары,
            //либо является пустой строкой (если Bне содержит ни одной подходящей строки).
            //Результирующая последовательность называется левым внешним объединением
            //последовательностей A и B по ключу, определяемому первыми символами исходных строк.
            //Представить найденное объединение в виде последовательности строк вида «EA.EB», где EA
            //– элемент из A, а EB – либо один из соответствующих ему элементов из B, либо пустая строка.
            //Расположить элементы полученной строковой последовательности в лексикографическом порядке по возрастанию.
            //Указание.Использовать методы GroupJoin, DefaultIfEmpty, Select и SelectMany.
            //Примечание.Решение данной задачи приведено в п. 5.5.4.

            (from e1 in new[] { "B", "I", "G", "DJC", "2", "ICF", "E7", "CAB", "HE", "8", "AD2", "FI2" }
             join e2 in new[] { "EA", "8", "74I", "J8B", "C", "HGH", "G", "AA7", "9", "GF5" }
             on e1[0] equals e2[0]
             into ee2
             from e in ee2.DefaultIfEmpty("")
             let r = e1 + "." + e
             orderby r
             select r).Show();
            Console.WriteLine("\n");

            //LinqBegin55.Даны последовательности положительных целых
            //чисел Aи B; все числа в каждой последовательности различны.
            //Найти левое внешнее объединение A и B(см. LinqBegin54),
            //пары в котором должны удовлетворять следующему условию: оба элемента
            //пары оканчиваются одной и той же цифрой. Представить найденное
            //объединение в виде последовательности строк вида «EA:EB», где EA – число из A,
            //а EB – либо одно из соответствующих ему чисел из B, либо 0
            //(если в B не содержится чисел, соответствующих EA).
            //Расположить элементы полученной последовательности по убыванию чисел EA,
            //а при одинаковых числах EA – по возрастанию чисел EB.

            //LinqBegin56.Дана целочисленная последовательность A.
            //Сгруппироватьэлементы последовательности A, оканчивающиеся одной
            //и той же цифрой, и на основе этой группировки получить последовательность
            //строк вида «D:S», где D– ключ группировки(то есть некоторая цифра,
            //которой оканчивается хотя бы одно из чисел по-следовательности A),
            //а S– сумма всех чисел из A, которые оканчиваются цифрой D.
            //Полученную последовательность упорядочить по возрастанию ключей.
            //Указание.Использовать метод GroupBy.

            //LinqBegin57.Дана целочисленная последовательность.
            //Среди всех элементов последовательности, оканчивающихся одной и той
            //же цифрой, выбрать максимальный. Полученную последовательность максимальных
            //элементов упорядочить по возрастанию их последних цифр.

            //LinqBegin58.Дана последовательность непустых строк. Среди
            //всех строк, начинающихся с одного и того же символа, выбрать наиболее длинную.
            //Если таких строк несколько, то выбрать первую по порядку их следования в
            //исходной последовательности. Полученную последовательность строк упорядочить
            //по возрастанию кодов их начальных символов.

            //LinqBegin59.Дана последовательность непустых строк, содержащих только
            //заглавные буквы латинского алфавита. Среди всех строк одинаковой длины
            //выбрать первую в лексикографическом порядке (по возрастанию).
            //Полученную последовательность строк упорядочить по убыванию их длин.

            //LinqBegin60.Дана последовательность непустых строк A, содержащих только заглавные
            //буквы латинского алфавита. Для всех строк, начинающихся с одной и той же буквы,
            //определить их сум-марную длину и получить последовательность строк вида «S-C», где
            //S– суммарная длина всех строк из A, которые начинаются с буквы С.
            //Полученную последовательность упорядочить по убыванию числовых значений сумм,
            //а при равных значениях сумм – по возрас-танию кодов символов C.
            //Примечание.Решение данной задачи приведено в п. 5.6.
            string[] el = { "QWJ", "OGS", "DA", "HHCO", "SXZ", "B", "SPPM", "YHBR", "OPLU", "JY", "ZOFX", "ODMQF", "ZAFK", "WJBQ" };
            (from e in el
             group e.Length by e[0]
             into r
             let s = r.Sum()
             let k = r.Key
             orderby s descending, k
             select s + "-" + k).Show();

            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
