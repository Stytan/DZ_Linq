/*
 * Created by SharpDevelop.
 * User: sergey.lezhenko
 * Date: 04.09.2017
 * Time: 10:54
 * 
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 */
using System;
using System.Collections;
using System.Linq;
using System.Reflection;
using System.Text;

namespace DZ_LINQ
{
    public static class ExMethods
    {
        public static void Show(this IEnumerable seq)
        {
            IEnumerator el = seq.GetEnumerator();
            while (el.MoveNext())
            {
                Console.Write(el.Current + " ");
            }
        }
        public static void Show(this object el)
        {
            Console.Write(el.ToString() + " ");
        }
    }
    class Program
    {
        static void Task0()
        {
            Console.WriteLine("Good buy!");
        }
        static void Task1()
        {
            Console.WriteLine(
                "\nLinqBegin1\n"
                + "Дана целочисленная последовательность, содержащая\n"
                + "как положительные, так и отрицательные числа.Вывести ее первый\n"
                + "положительный элемент и последний отрицательный элемент.\n"
                + "int[] e = { 4, 12, -6, -4, -32, 47, 32, 96, 0, 23, -5, -3, -75, 15 }");
            int[] e = { 4, 12, -6, -4, -32, 47, 32, 96, 0, 23, -5, -3, -75, 15 };
            Console.WriteLine(e.FirstOrDefault(a => a > 0));
            Console.WriteLine(e.LastOrDefault(a => a < 0));
        }
        static void Task2()
        {
            Console.WriteLine(
                "\nLinqBegin2\n"
                + "Даны цифра D (однозначное целое число) и целочисленная последовательность A.\n"
                + "Вывести первый положительный элемент последовательности A, оканчивающийся цифрой  D.\n"
                + "Если требуемых элементов в последовательности A нет, то вывести 0.\n"
                + "int D = 2;\n"
                + "int[] A = { 4, 12, -6, -4, -32, 47, 32, 96, 0, 23, -5, -3, -75, 15 };");
            int D = 2;
            int[] A = { 4, 12, -6, -4, -32, 47, 32, 96, 0, 23, -5, -3, -75, 15 };
            Console.WriteLine(
                A.FirstOrDefault(r => r > 0 && r.ToString().EndsWith(D.ToString(), StringComparison.CurrentCulture))
                );
        }
        static void Task3()
        {
            Console.WriteLine(
                "\nLinqBegin3\n"
                + "Даны целое число L(> 0) и строковая последовательность A.\n"
                + "Вывести последнюю строку из A, начинающуюся с цифры и имеющую длину L.\n"
                + "Если требуемых строк в последовательности A нет, то вывести строку «Not found».\n"
                + "Указание.Для обработки ситуации, связанной с отсутствием требуемых строк, использовать операцию ??."
                + "int L = 4;\n"
                + "string[] A = { \"8pOl\", \"\", \"OOHNG\", \"2J\", \"jle\", \"ojRa\", \"UTq\", \"4A3\", \"\", \"bh\", \"p\", \"daW\" };"
                );
            int L = 4;
            string[] A = { "8pOl", "", "OOHNG", "2J", "jle", "ojRa", "UTq", "4A3", "", "bh", "p", "daW" };
            Console.WriteLine(
                A.LastOrDefault(r => r.Length == L && r.IndexOfAny(
                    new[] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' }) == 0) ?? "Not found"
                );
        }

        static void Task4()
        {
            Console.WriteLine(
                "\nLinqBegin4:\n"
                + "Даны символ С и строковая последовательность A.\n"
                + "Если A содержит единственный элемент, оканчивающийся символом C,\n"
                + "то вывести этот элемент; если требуемых строк в A нет, то\n"
                + "вывести пустую строку; если требуемых строк больше одной, то вывести строку «Error».\n"
                + "Указание.Использовать try-блок для перехвата возможного исключения.\n"
                + "Примечание.Решение данной задачи приведено в п. 5.1.\n"
                + "const char c = 'l';\n"
                + "string[] A = { \"8pOvl\", \"\", \"OOHNG\", \"2J\", \"jle\", \"ojRa\", \"UTq\", \"4A3\", \"\", \"bh\", \"p\", \"daW\" };\n");
            const char c = 'l';
            string[] A = { "8pOvl", "", "OOHNG", "2J", "jle", "ojRa", "UTq", "4A3", "", "bh", "p", "daW" };
            try
            {
                Console.WriteLine(
                    A.SingleOrDefault(e => e.Length != 0 && e[e.Length - 1] == c) ?? ""
                    );
            }
            catch
            {
                Console.WriteLine("Error");
            }
        }
        static void Task5()
        {
            Console.WriteLine(
                "\nLinqBegin5\n"
                + "Даны символ С и строковая последовательность A.\n"
                + "Найти количество элементов A, которые содержат более одного\n"
                + "символа и при этом начинаются и оканчиваются символом C.\n"
                + "char C = 'O';\n"
                + "string[] A = { \"8pOl\", \"\", \"OOHNGO\", \"2J\", \"OjleO\", \"ojRa\", \"OUOTq\", \"4A3\", \"\", \"bh\", \"p\", \"daW\" };\n"
                );
            char C = 'O';
            string[] A = { "8pOl", "", "OOHNGO", "2J", "OjleO", "ojRa", "OUOTq", "4A3", "", "bh", "p", "daW" };
            Console.WriteLine(
                A.Count(r => r.Length > 1
                && r.StartsWith(C.ToString(), StringComparison.Ordinal)
                && r.EndsWith(C.ToString(), StringComparison.Ordinal))
                );
        }
        static void Task6()
        {
            Console.WriteLine(
                "\nLinqBegin6\n"
                + "Дана строковая последовательность.\n"
                + "Найти сумму длин всех строк, входящих в данную последовательность.\n"
                + "string[] A = { \"8pOl\", \"\", \"OOHNGO\", \"2J\", \"OjleO\", \"ojRa\", \"OUOTq\", \"4A3\", \"\", \"bh\", \"p\", \"daW\" };\n"
                );
            string[] A = { "8pOl", "", "OOHNGO", "2J", "OjleO", "ojRa", "OUOTq", "4A3", "", "bh", "p", "daW" };
            Console.Write(
                A.Sum(r => r.Length)
                );
        }
        static void Task7()
        {
            Console.WriteLine(
                "\nLinqBegin7\n"
                + "Дана целочисленная последовательность.\n"
                + "Найти количество ее отрицательных элементов, а также их сумму.\n"
                + "Если отрицательные элементы отсутствуют, то дважды вывести 0.\n"
                + "int[] A = { 4, 12, -6, 4, -32, -47, 32, 96, 0, 23, 5, -3, -75, 15 };\n"
                );
            int[] A = { 4, 12, -6, 4, -32, -47, 32, 96, 0, 23, 5, -3, -75, 15 };
            Console.WriteLine(
                "Count = {0}, Sum = {1}",
                A.Count(r => r < 0), A.Sum(r => r < 0 ? r : 0)
                );
        }
        static void Task8()
        {
            Console.WriteLine(
                "\nLinqBegin8\n"
                + "Дана целочисленная последовательность.\n"
                + "Найти количество ее положительных двузначных элементов,\n"
                + "а также их среднее арифметическое (как вещественное число).\n"
                + "Если требуемые элементы отсутствуют, то дважды вывести 0 \n"
                + "(первый раз как целое, второй – как вещественное).\n"
                + "int[] A = { -4, -12, -6, -4, 32, -47, 32, -96, 0, 23, -5, 3, -75, -15 };");
            int[] A = { -4, -12, -6, -4, 32, -47, 32, -96, 0, 23, -5, 3, -75, -15 };
            var res = from a in A
                      where a > 0 && a.ToString().Length == 2
                      select a;
            Console.WriteLine(
                "Count = {0}, Sum = {1}",
                res.Count(),
                res.Count() > 0 ? res.Average() : 0.0);
        }
        static void Task9()
        {
            Console.WriteLine(
                "\nLinqBegin9\n"
                + "Дана целочисленная последовательность.\n"
                + "Вывести ее минимальный положительный элемент или число 0,\n"
                + "если последовательность не содержит положительных элементов.\n"
                + "int[] A = { -4, -12, -6, -4, 32, -47, -32, 96, -23, -5, 3, -75, -15 };\n"
                + "\n"
                + "\n"
                + "\n");
            int[] A = { -4, -12, -6, -4, 32, -47, -32, 96, -23, -5, 3, -75, -15 };
            var res = from a in A
                      where a > 0
                      select a;
            Console.WriteLine(
                "Min = {0}",
                res.Count() > 0 ? res.Min() : 0);
        }
        static void Task10()
        {
            Console.WriteLine(
                "\nLinqBegin10\n"
                + "Даны целое число L(> 0) и строковая последовательность A.\n"
                + "Строки последовательности A содержат только заглавные буквы латинского алфавита.\n"
                + "Среди всех строк из A, имеющих длину L, найти наибольшую (в смысле лексикографического порядка).\n"
                + "Вывести эту строку или пустую строку, если последовательность не содержит строк длины L.\n"
                + "int L = 5;\n"
                + "string[] A = { \"HDSJ\", \"\", \"OOHNGO\", \"J\", \"OSFHO\", \"HTREWDA\", \"WUGOT\", \"EW\", \"QWRQRQ\", \"QWERG\", \"WERGX\", \"FASSS\" };"
                );
            int L = 5;
            string[] A = { "HDSJ", "", "OOHNGO", "J", "OSFHO", "HTREWDA", "WUGOT", "EW", "QWRQRQ", "QWERG", "WERGX", "FASSS" };
            Console.WriteLine(
                "Max str = {0}",
                (from a in A
                 where a.Length == L
                 orderby a descending
                 select a)
                 .FirstOrDefault() ?? "");
        }
        static void Task11()
        {
            Console.WriteLine(
                "\nLinqBegin11\n"
                + "Дана последовательность непустых строк.\n"
                + "Используя метод Aggregate, получить строку, состоящую из\n"
                + "начальных символов всех строк исходной последовательности.\n"
                + "string[] A = { \"HDSJ\", \"\", \"OOHNGO\", \"J\", \"OSFHO\", \"HTREWDA\", \"WUGOT\", \"EW\", \"QWRQRQ\", \"QWERG\", \"WERGX\", \"FASSS\" };"
                );
            string[] A = { "HDSJ", "", "OOHNGO", "J", "OSFHO", "HTREWDA", "WUGOT", "EW", "QWRQRQ", "QWERG", "WERGX", "FASSS" };
            Console.WriteLine(
                "Aggregate str = {0}",
                (from a in A
                 where (a != null && a.Length > 0)
                 select a[0])
                 .Aggregate("", (r, c) => r + c));
        }
        static void Task12()
        {
            Console.WriteLine(
                "\nLinqBegin12\n"
                + "Дана целочисленная последовательность.\n"
                + "Используя метод Aggregate, найти произведение последних цифр\n"
                + "всех элементов последовательности.\n"
                + "Чтобы избежать целочисленного переполнения,\n"
                + "при вычислении произведения использовать вещественный числовой тип.\n"
                + "int[] A = { -4, 12, -6, -4, 32, -47, -32, 96, -23, -5, 3, -75, -15 };"
                );
            int[] A = { -4, 12, -6, -4, 32, -47, -32, 96, -23, -5, 3, -75, -15 };
            Console.WriteLine(
                "Mult = {0}",
                (from a in A
                 let r = Char.GetNumericValue(a.ToString().LastOrDefault())
                 select r)
                 .Aggregate(1.0, (i, j) => i * j));
        }
        static void Task13()
        {
            Console.WriteLine(
                "\nLinqBegin13\n"
                + "Дано целое число N (> 0). Используя методы Range\n"
                + "и Sum, найти сумму 1 + (1/2) + … + (1/N) (как вещественное число).\n"
                + "int A = 6;"
                );
            int A = 6;
            Console.WriteLine(
                "Sum = {0}",
                Enumerable.Range(1, A)
                .Sum(i => (1.0 / i)));
        }
        static void Task14()
        {
            Console.WriteLine(
                "\nLinqBegin14\n"
                + "Даны целые числа A и B(A< B).\n"
                + "Используя мето-ды Range и Average, найти среднее арифметическое квадратов всех\n"
                + "целых чисел от A до B включительно:\n"
                + "(A^2 + (A + 1)^2 + … + B^2)/(B – A + 1) (как вещественное число).\n"
                + "int A = 5, B = 10;");
            int A = 5, B = 10;
            Console.WriteLine(
                "Avg = {0}",
                Enumerable.Range(A, B - A + 1)
                .Average(i => i * i));
        }
        static void Task15()
        {
            Console.WriteLine(
                "\nLinqBegin15:\n"
                + "Дано целое число N(0 <= N <= 15). Используя методы Range и Aggregate,\n"
                + "найти факториал числа N: N! = 1·2·…·N при N >= 1; 0! = 1.\n"
                + "Чтобы избежать целочисленного переполнения, при\n"
                + "вычислении факториала использовать вещественный числовой тип.\n"
                + "Примечание.Решение данной задачи приведено в п. 5.2.\n"
                + "const int N = 5;");
            int N = 5;
            Console.WriteLine(
                Enumerable.Range(1, N)
                .Aggregate(1.0, (a, e) => a * e));
        }
        //2.2. Фильтрация, сортировка,
        //теоретико-множественные операции
        //Изучаемые запросы LINQ:
        //Where , TakeWhile , SkipWhile , Take , Skip (фильтрация);
        //OrderBy , OrderByDescending , ThenBy , ThenByDescending (сортировка);
        //Distinct , Reverse (удаление повторяющихся элементов и инвертирование);
        //Union , Intersect , Except (теоретико-множественные операции)
        static void Task16()
        {
            Console.WriteLine(
                "\nLinqBegin16:\n"
                + "Дана целочисленная последовательность.\n"
                + "Извлечь из нее все положительные числа,\n"
                + "сохранив их исходный порядок следования.\n"
                + "int[] A = { -4, 12, -6, -4, 32, -47, -32, 96, -23, -5, 3, -75, -15 };");
            int[] A = { -4, 12, -6, -4, 32, -47, -32, 96, -23, -5, 3, -75, -15 };
            (from a in A
             where a > 0
             select a).Show();
            Console.WriteLine();
        }
        static void Task17()
        {
            Console.WriteLine(
                "\nLinqBegin17\n"
                + "Дана целочисленная последовательность.\n"
                + "Извлечь из нее все нечетные числа, сохранив их исходный порядок следования\n"
                + "и удалив все вхождения повторяющихся элементов, кроме первых.\n"
                + "int[] A = { -4, 12, -6, -4, 32, -47, -32, 96, -23, -5, 3, -75, -15 };");
            int[] A = { -4, 12, -6, -4, 32, -47, -32, 96, -23, -5, 3, -75, -15 };
            (from a in A
             where a % 2 != 0
             select a).Distinct().Show();
        }
        static void Task18()
        {
            Console.WriteLine(
                "\nLinqBegin18\n"
                + "Дана целочисленная последовательность.\n"
                + "Извлечь из нее все четные отрицательные числа,\n"
                + "поменяв порядок извлеченных чисел на обратный.\n"
                + "int[] A = { -4, 12, -6, -4, 32, -47, -32, 96, -23, -5, 3, -75, -15 };");
            int[] A = { -4, 12, -6, -4, 32, -47, -32, 96, -23, -5, 3, -75, -15 };
            (from a in A
             where a % 2 != 0 && a < 0
             select a).Reverse().Show();
        }
        static void Task19()
        {
            Console.WriteLine(
                "\nLinqBegin19\n"
                + "Даны цифра D(целое однозначное число) и целочисленная последовательность A.\n"
                + "Извлечь из A все различные положительные числа, оканчивающиеся цифрой D(в исходном порядке).\n"
                + "При наличии повторяющихся элементов удалять все их вхождения, кроме последних.\n"
                + "Указание.Последовательно применить методы Reverse, Distinct, Reverse.\n"
                + "int D = 4;\n"
                + "int[] A = { -4, 12, -6, -4, 34, -47, -34, 96, -24, -5, 34, 3, -75, -4, -15 };\n"
                + "\n");
            int D = 4;
            int[] A = { -4, 12, -6, -4, 34, -47, -34, 96, -24, -5, 34, 3, -75, -4, -15 };
            (from a in A
             where a.ToString().EndsWith(D.ToString())
             select a).Reverse().Distinct().Reverse().Show();
        }
        static void Task20()
        {
            Console.WriteLine(
                "\nLinqBegin20\n"
                + "Дана целочисленная последовательность.\n"
                + "Извлечь из нее все положительные двузначные числа,\n"
                + "отсортировав их по возрастанию.\n"
                + "int[] A = { -4, 12, -6, -4, 34, -47, -34, 96, -24, -5, 34, 3, -75, -4, -15 };");
            int[] A = { -4, 12, -6, -4, 34, -47, -34, 96, -24, -5, 34, 3, -75, -4, -15 };
            (from a in A
             where a > 0 && a.ToString().Length == 2
             orderby a
             select a).Show();
        }
        static void Task21()
        {
            Console.WriteLine(
                "\nLinqBegin21\n"
                + "Дана строковая последовательность.\n"
                + "Строки последовательности содержат только заглавные буквы латинского алфавита.\n"
                + "Отсортировать последовательность по возрастанию длин строк,\n"
                + "а строки одинаковой длины – в лексикографическом порядке по убыванию.\n"
                + "string[] A = { \"HDSJ\", \"\", \"OOHNGO\", \"J\", \"OSFHO\", \"HTREWDA\", \"WUGOT\", \"EW\", \"QWRQRQ\", \"QWERG\", \"WERGX\", \"FASSS\" };\n");
            string[] A = { "HDSJ", "", "OOHNGO", "J", "OSFHO", "HTREWDA", "WUGOT", "EW", "QWRQRQ", "QWERG", "WERGX", "FASSS" };
            A.OrderByDescending(a => a).OrderBy(a => a.Length).Show();
        }
        static void Task22()
        {
            Console.WriteLine(
                "\nLinqBegin22\n"
                + "Даны целое число K(> 0) и строковая последовательность A.\n"
                + "Строки последовательности содержат только цифры\n"
                + "и заглавные буквы латинского алфавита.\n"
                + "Извлечь из A все строки длины K, оканчивающиеся цифрой,\n"
                + "отсортировав их в лексикографическом порядке по возрастанию.\n"
                + "int K = 5;\n"
                + "string[] A = { \"HDSJ5\", \"\", \"OOH3N4GO\", \"J3\", \"O5SHO\", \"H5TREWDA\", \"WUGOT\", \"EW7\", \"Q6WRQR4Q4\", \"Q3WERG1\", \"W6ERG6X\", \"FASSS8\" };");
            int K = 5;
            string[] A = { "HDSJ5", "", "OOH3N4GO", "J3", "O5SFHO", "H5TREWDA", "WU7GOT", "EW7", "Q64Q4", "Q3RG1", "W6ERG6X", "FASSS8" };
            (from a in A
             where a.Length == K && a.LastOrDefault() > '0' && a.LastOrDefault() < '9'
             orderby a
             select a).Show();
        }
        static void Task46()
        {
            Console.WriteLine(
    "\nLinqBegin46\n"
    + "Даны последовательности положительных целых чисел Aи B;\n"
    + "все числа в каждой последовательности различны.\n"
    + "Найти последовательность всех пар чисел, удовлетворяющих следующим условиям:\n"
    + "первый элемент пары принадлежит последовательности A, второй принадлежит B,\n"
    + "и оба элемента оканчиваются одной и той же цифрой.\n"
    + "Результирующая последовательность называется внутренним объединением\n"
    + "последовательностей A и B по ключу, определяемому последними цифрами исходных чисел.\n"
    + "Представить найденное объединение в виде последовательности строк,\n"
    + "содержащих первый и второй элементы пары, разделенные дефисом,\n"
    + "например «49-129». Порядок следования пар должен определяться\n"
    + "исходным порядком элементов последовательности A, а для равных\n"
    + "первых элементов – порядком элементов последовательности B.");
            int[] A = { 5, 6, 8, 12, 43, 67, 876 };
            int[] B = { 7, 9, 42, 11, 22, 54, 62 };
            var res = A.Join(B.OrderBy(b=>b), a=>a%10, b=>b%10, (a,b)=>a+"-"+b);
            res.Show();
            Console.WriteLine();
        }
        //LinqBegin47.Даны последовательности положительных целых
        //чисел A и B; все числа в каждой последовательности различны.
        //Найти внутреннее объединение A и B(см. LinqBegin46),
        //пары в котором должны удовлетворять следующему условию:
        //последняя цифра первого элемента пары (из A) должна совпадать
        //с первой цифрой второго элемента пары (из B).
        //Представить найденное объединение в виде последовательности строк,
        //содержащих первый и второй элементы пары, разделенные двоеточием,
        //например «49:921». Порядок следования пар должен определяться исходным порядком
        //элементов последовательности A, а для равных первых элементов пар –
        //лексикографическим порядком строковых представлений вторых элементов (по возрастанию).
        static void Task47()
        {
            Console.WriteLine("\nLinqBegin46\n");
            int[] A = { 5, 6, 8, 12, 43, 67, 876 };
            int[] B = { 7, 9, 42, 11, 22, 54, 62 };
            var res = A.Select(a => a.ToString()).Join(
                B.Select(b => b.ToString()).OrderBy(b => b),
                a => int.Parse(a) % 10,
                b => int.Parse(b[0].ToString()),
                (a, b) => a + ":" + b);
        }

        public static void Main(string[] args)
        {
            string N;
            do
            {
                Console.Write("Input task (0 - to exit, 99 - to all tasks): ");
                N = Console.ReadLine();
                //Получаем методы
                MethodInfo[] MI = typeof(Program).GetMethods(BindingFlags.Static | BindingFlags.NonPublic);
                //Показываем их
                try
                {
                    //Выбираем метод который нам нужен по имени
                    MethodInfo method = MI.Where(a => a.Name == "Task" + N).First();
                    //Вызываем его
                    method.Invoke(null, null);
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.Message);
                }
            } while (N != "0");


            Console.WriteLine("\n\n");












            //LinqBegin23.Даны целое число K(> 0) и целочисленная после-довательность A.
            //Начиная с элемента A с порядковым номером K,
            //извлечь из A все нечетные двузначные числа, отсортировав их по убыванию.

            //LinqBegin24.Даны целое число K(> 0) и строковая последовательность A.
            //Из элементов A, предшествующих элементу с порядковым номером K,
            //извлечь те строки, которые имеют нечетную длину и начинаются с заглавной латинской буквы,
            //изменив порядок сле-дования извлеченных строк на обратный.

            //LinqBegin25.Даны целые числа K1 и K2 и целочисленная после-довательность A;
            //1 <= K1 < K2 <= N, где N–размер последовательности A.
            //Найти сумму положительных элементов последовательности
            //с порядковыми номерами от K1 до K2 включительно.

            //LinqBegin26.Даны целые числа K1 и K2 и последовательность непустых строк A;
            //1 < K1 < K2 <= N, где N–размер последовательности A.
            //Найти среднее арифметическое длин всех элементов последовательности,
            //кроме элементов с порядковыми номерами от K1 до K2
            //включительно, и вывести его как вещественное число.

            //LinqBegin27.Даны целое число D и целочисленная последовательность A.
            //Начиная с первого элемента A, большего D, извлечь из
            //A все нечетные положительные числа, поменяв порядок извлеченных чисел на обратный.

            //LinqBegin28.Даны целое число L(> 0) и последовательность непустых строк A.
            //Строки последовательности содержат только цифры и заглавные буквы латинского алфавита.
            //Из элементов A, предшествующих первому элементу, длина которого превышает L, извлечь
            //строки, оканчивающиеся буквой. Полученную последовательность
            //отсортировать по убыванию длин строк, а строки одинаковой длины –
            //в лексикографическом порядке по возрастанию.

            //LinqBegin29.Даны целые числа D и K(K> 0) и целочисленная последовательность A.
            //Найти теоретико-множественное объединение двух фрагментов A:
            //первый содержит все элементы до первого элемента, большего D(не включая его),
            //а второй – все элементы, начиная с элемента с порядковым номером K.
            //Полученную последовательность (не содержащую одинаковых элементов) отсортировать по убыванию.

            //LinqBegin30.Даны целое число K(> 0) и целочисленная последовательность A.
            //Найти теоретико-множественную разность двух фрагментов A:
            //первый содержит все четные числа, а второй – все числа с порядковыми номерами, большими K.
            //В полученной последовательности (не содержащей одинаковых элементов) поменять
            //порядок элементов на обратный.

            //LinqBegin31.Даны целое число K(> 0) и последовательность
            //непустых строк A. Строки последовательности содержат только
            //цифры и заглавные буквы латинского алфавита.
            //Найти теоретико-множественное пересечение двух фрагментов A: первый содержит
            //K начальных элементов, а второй – все элементы, расположенные
            //после последнего элемента, оканчивающегося цифрой. Полученную
            //последовательность (не содержащую одинаковых элементов) отсортировать
            //по возрастанию длин строк, а строки одинаковой длины –
            //в лексикографическом порядке по возрастанию.
            //Примечание. Решение данной задачи приведено в п. 5.3

            //2.3. Проецирование
            //Изучаемые запросы LINQ:
            //Select , SelectMany (проецирование).

            //LinqBegin32.Дана последовательность непустых строк A.
            //Получить последовательность символов, каждый элемент которой
            //является начальным символом соответствующей строки из A.
            //Порядок символов должен быть обратным по отношению к порядку
            //элементов исходной последовательности.

            //LinqBegin33.Дана целочисленная последовательность.
            //Обрабатывая только положительные числа, получить последовательность
            //их последних цифр и удалить в полученной последовательности все
            //вхождения одинаковых цифр, кроме первого. Порядок полученных
            //цифр должен соответствовать порядку исходных чисел.

            //LinqBegin34.Дана последовательность положительных целых чисел.
            //Обрабатывая только нечетные числа, получить последовательность
            //их строковых представлений и отсортировать ее в лексикографическом порядке по возрастанию.

            //LinqBegin35.Дана целочисленная последовательность. Получить
            //последовательность чисел, каждый элемент которой равен произведению
            //соответствующего элемента исходной последовательности на
            //его порядковый номер (1, 2, …). В полученной последовательности
            //удалить все элементы, не являющиеся двузначными,
            //и поменять порядок оставшихся элементов на обратный.

            //LinqBegin36.Дана последовательность непустых строк. Получить
            //последовательность символов, которая определяется следующим об-разом:
            //если соответствующая строка исходной последовательности
            //имеет нечетную длину, то в качестве символа берется первый символ
            //этой строки; в противном случае берется последний символ строки.
            //Отсортировать полученные символы по убыванию их кодов.

            //LinqBegin37.Дана строковая последовательность A.
            //Строки последовательности содержат только заглавные буквы латинского алфавита.
            //Получить новую последовательность строк, элементы которой определяются
            //по соответствующим элементам A следующим образом:
            //пустые строки в новую последовательность не включаются,
            //а к непустым приписывается порядковый номер данной строки
            //в исходной последовательности (например, если пятый элемент A имеет
            //вид «ABC», то в полученной последовательности он будет иметь
            //вид «ABC5»). При нумерации должны учитываться и пустые строки
            //последовательности A. Отсортировать полученную последовательность
            //в лексикографическом порядке по возрастанию.

            //LinqBegin38.Дана целочисленная последовательность A.
            //Получить новую последовательность чисел, элементы которой
            //определяются по соответствующим элементам последовательности
            //A следующим образом: если порядковый номер элемента A делится на 3 (3, 6, …),
            //то этот элемент в новую последовательность не включается;
            //если остаток от деления порядкового номера на 3 равен 1 (1, 4, …),
            //то в новую последовательность добавляется удвоенное значение этого элемента;
            //в противном случае (для элементов A с номерами 2, 5, …)
            //элемент добавляется в новую последовательность без изменений.
            //В полученной последовательности сохранить исходный
            //порядок следования элементов.

            //LinqBegin39.Дана строковая последовательность A.
            //Получить последовательность цифровых символов,
            //входящих в строки последовательности A (символы могут повторяться).
            //Порядок символов должен соответствовать порядку строк A и
            //порядку следования символов в каждой строке.
            //Указание.Использовать метод SelectMany с учетом того, что
            //строка может интерпретироваться как последовательность символов.

            //LinqBegin40.Даны число K(> 0) и строковая последовательность A.
            //Получить последовательность символов, содержащую символы
            //всех строк из A, имеющих длину, большую или равную K(символы
            //могут повторяться). В полученной последовательности поменять
            //порядок элементов на обратный.

            //LinqBegin41.Даны целое число K(> 0) и строковая последовательность A.
            //Каждый элемент последовательности представляет собой несколько слов
            //из заглавных латинских букв, разделенных символами «.» (точка).
            //Получить последовательность строк, содержащую все слова длины K
            //из элементов A в лексикографическом порядке по возрастанию (слова могут повторяться).

            //LinqBegin42.Дана последовательность непустых строк. Получить
            //последовательность символов, которая определяется следующим
            //образом: для строк с нечетными порядковыми номерами (1, 3, …)
            //в последовательность символов включаются все прописные латинские буквы,
            //содержащиеся в этих строках, а для строк с четными номерами (2, 4, …) –
            //все их строчные латинские буквы.
            //В полученной последовательности символов сохранить их исходный порядок следования.

            //LinqBegin43.Даны целое число K(> 0) и последовательность непустых строк A.
            //Получить последовательность символов, которая определяется следующим образом:
            //для первых K элементов последовательности A в новую последовательность заносятся символы,
            //стоящие на нечетных позициях данной строки (1, 3, …), а для остальных
            //элементов A– символы на четных позициях (2, 4, …).
            //В полученной последовательности поменять порядок элементов на обратный.
            //Примечание.Решение данной задачи приведено в п. 5.4.

            //2.4. Объединение и группировка
            //Изучаемые запросы LINQ:
            //Concat (сцепление);
            //Join , GroupJoin (объединение);
            //DefaultIfEmpty (замена пустой последовательности на одно-элементную);
            //GroupBy (группировка).

            //LinqBegin44.Даны целые числа K1 и K2 и целочисленные последовательности A и B.
            //Получить последовательность, содержащую все числа из A, большие K1,
            //и все числа из B, меньшие K2.
            //Отсортировать полученную последовательность по возрастанию.

            //LinqBegin45.Даны целые положительные числа L1 и L2 и строковые последовательности A и B.
            //Строки последовательностей содержат только цифры и заглавные буквы латинского алфавита.
            //Получить последовательность, содержащую все строки из A длины L1 и все строки из B длины L2.
            //Отсортировать полученную последовательность в лексикографическом порядке по убыванию.





            //LinqBegin48.Даны строковые последовательности A и B; все
            //строки в каждой последовательности различны, имеют ненулевую
            //длину и содержат только цифры и заглавные буквы латинского
            //алфавита. Найти внутреннее объединение A и B(см. LinqBegin46),
            //каждая пара которого должна содержать строки одинаковой длины.
            //Представить найденное объединение в виде последовательности
            //строк, содержащих первый и второй элементы пары, разделенные
            //двоеточием, например «AB:CD». Порядок следования пар должен
            //определяться лексикографическим порядком первых элементов пар
            //(по возрастанию), а для равных первых элементов – лексикографическим
            //порядком вторых элементов пар (по убыванию).

            //LinqBegin49.Даны строковые последовательности A, Bи С;
            //все строки в каждой последовательности различны, имеют ненулевую
            //длину и содержат только цифры и заглавные буквы латинского алфавита.
            //Найти внутреннее объединение A, B и С(см. LinqBegin46),
            //каждая тройка которого должна содержать строки, начинающиеся
            //с одного и того же символа. Представить найденное объединение
            //в виде последовательности строк вида «EA=EB=EC», где EA, EB, EC –
            //элементы из A, B, C соответственно. Для различных элементов EA
            //сохраняется исходный порядок их следования, для равных элементов EA
            //порядок троек определяется лексикографическим порядком элементов EB
            //(по возрастанию), а для равных элементов EA и EB –
            //лексикографическим порядком элементов EC (по убыванию).

            //LinqBegin50.Даны строковые последовательности Aи B; все
            //строки в каждой последовательности различны и имеют ненулевую
            //длину. Получить последовательность строк вида «E:N»,
            //где E обозначает один из элементов последовательности A, а N–количество
            //элементов из B, начинающихся с того же символа, что и элемент
            //E(например, «abc:4»); количество N может быть равно 0. Порядок
            //элементов полученной последовательности должен определяться
            //исходным порядком элементов последовательности A.
            //Указание.Использовать метод GroupJoin.

            //LinqBegin51.Даны последовательности положительных целых
            //чисел A и B; все числа в последовательности Aразличны. Получить
            //последовательность строк вида «S:E», где S обозначает сумму тех
            //чисел из B, которые оканчиваются на ту же цифру, что и число E–
            //один из элементов последовательности A (например, «74:23»); если
            //для числа E не найдено ни одного подходящего числа из последовательности B,
            //то в качестве S указать 0. Расположить элементы полученной последовательности
            //по возрастанию значений найденных сумм, а при равных суммах –
            //по убыванию значений элементов A.

            //LinqBegin52.Даны строковые последовательности Aи B; все
            //строки в каждой последовательности различны, имеют ненулевую
            //длину и содержат только цифры и заглавные буквы латинского алфавита.
            //Получить последовательность всевозможных комбинаций вида «EA=EB», где EA
            //– некоторый элемент из A, EB – некоторый элемент из B,
            //причем оба элемента оканчиваются цифрой (например, «AF3=D78»).
            //Упорядочить полученную последовательность в лексикографическом порядке
            //по возрастанию элементов EA, а при одинаковых элементах EA
            //– в лексикографическом порядке по убыванию элементов EB.
            //Указание.Для перебора комбинаций использовать методы Select Many и Select.
            //Примечание.Решение данной задачи приведено в п. 5.5.2.

            //LinqBegin53.Даны целочисленные последовательности A и B.
            //Получить последовательность всех различныхсумм, в которых первое
            //слагаемое берется из A, а второе – из B. Упорядочить полученную
            //последовательность по возрастанию.

            //LinqBegin54.Даны строковые последовательности A и B; все
            //строки в каждой последовательности различны, имеют ненулевую
            //длину и содержат только цифры и заглавные буквы латинского алфавита.
            //Найти последовательность всех пар строк, удовлетворяющих следующим условиям:
            //первый элемент пары принадлежит последовательности A,
            //а второй либо является одним из элементов последовательности B,
            //начинающихся с того же символа, что и первый элемент пары,
            //либо является пустой строкой (если Bне содержит ни одной подходящей строки).
            //Результирующая последовательность называется левым внешним объединением
            //последовательностей A и B по ключу, определяемому первыми символами исходных строк.
            //Представить найденное объединение в виде последовательности строк вида «EA.EB», где EA
            //– элемент из A, а EB – либо один из соответствующих ему элементов из B, либо пустая строка.
            //Расположить элементы полученной строковой последовательности в лексикографическом порядке по возрастанию.
            //Указание.Использовать методы GroupJoin, DefaultIfEmpty, Select и SelectMany.
            //Примечание.Решение данной задачи приведено в п. 5.5.4.

            (from e1 in new[] { "B", "I", "G", "DJC", "2", "ICF", "E7", "CAB", "HE", "8", "AD2", "FI2" }
             join e2 in new[] { "EA", "8", "74I", "J8B", "C", "HGH", "G", "AA7", "9", "GF5" }
             on e1[0] equals e2[0]
             into ee2
             from e in ee2.DefaultIfEmpty("")
             let r = e1 + "." + e
             orderby r
             select r).Show();
            Console.WriteLine("\n");

            //LinqBegin55.Даны последовательности положительных целых
            //чисел Aи B; все числа в каждой последовательности различны.
            //Найти левое внешнее объединение A и B(см. LinqBegin54),
            //пары в котором должны удовлетворять следующему условию: оба элемента
            //пары оканчиваются одной и той же цифрой. Представить найденное
            //объединение в виде последовательности строк вида «EA:EB», где EA – число из A,
            //а EB – либо одно из соответствующих ему чисел из B, либо 0
            //(если в B не содержится чисел, соответствующих EA).
            //Расположить элементы полученной последовательности по убыванию чисел EA,
            //а при одинаковых числах EA – по возрастанию чисел EB.

            //LinqBegin56.Дана целочисленная последовательность A.
            //Сгруппироватьэлементы последовательности A, оканчивающиеся одной
            //и той же цифрой, и на основе этой группировки получить последовательность
            //строк вида «D:S», где D– ключ группировки(то есть некоторая цифра,
            //которой оканчивается хотя бы одно из чисел по-следовательности A),
            //а S– сумма всех чисел из A, которые оканчиваются цифрой D.
            //Полученную последовательность упорядочить по возрастанию ключей.
            //Указание.Использовать метод GroupBy.

            //LinqBegin57.Дана целочисленная последовательность.
            //Среди всех элементов последовательности, оканчивающихся одной и той
            //же цифрой, выбрать максимальный. Полученную последовательность максимальных
            //элементов упорядочить по возрастанию их последних цифр.

            //LinqBegin58.Дана последовательность непустых строк. Среди
            //всех строк, начинающихся с одного и того же символа, выбрать наиболее длинную.
            //Если таких строк несколько, то выбрать первую по порядку их следования в
            //исходной последовательности. Полученную последовательность строк упорядочить
            //по возрастанию кодов их начальных символов.

            //LinqBegin59.Дана последовательность непустых строк, содержащих только
            //заглавные буквы латинского алфавита. Среди всех строк одинаковой длины
            //выбрать первую в лексикографическом порядке (по возрастанию).
            //Полученную последовательность строк упорядочить по убыванию их длин.

            //LinqBegin60.Дана последовательность непустых строк A, содержащих только заглавные
            //буквы латинского алфавита. Для всех строк, начинающихся с одной и той же буквы,
            //определить их сум-марную длину и получить последовательность строк вида «S-C», где
            //S– суммарная длина всех строк из A, которые начинаются с буквы С.
            //Полученную последовательность упорядочить по убыванию числовых значений сумм,
            //а при равных значениях сумм – по возрас-танию кодов символов C.
            //Примечание.Решение данной задачи приведено в п. 5.6.
            string[] el = { "QWJ", "OGS", "DA", "HHCO", "SXZ", "B", "SPPM", "YHBR", "OPLU", "JY", "ZOFX", "ODMQF", "ZAFK", "WJBQ" };
            (from e in el
             group e.Length by e[0]
                 into r
                 let s = r.Sum()
                 let k = r.Key
                 orderby s descending, k
                 select s + "-" + k).Show();

            Console.Write("Press any key to continue . . . ");
            Console.ReadKey(true);
        }
    }
}
